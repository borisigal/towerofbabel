# Story 3.4: Integrate Lemon Squeezy for Subscriptions and Metered Billing

<!-- Powered by BMAD™ Core -->

## Status

**Draft**

---

## Story

**As a** user,
**I want** to subscribe to Pro tier or pay-per-use with monthly billing,
**so that** I can continue using TowerOfBabel after my trial ends.

---

## Acceptance Criteria

1. Lemon Squeezy account created and configured (test mode and production mode)
2. Lemon Squeezy Product created for Pro tier: "$10/month recurring subscription"
3. Lemon Squeezy Usage-Based Subscription created for PAYG tier: "$0/month base + $0.50 per interpretation metered"
4. Lemon Squeezy Checkout session created when user clicks "Subscribe to Pro"
5. Checkout session redirects to Lemon Squeezy hosted page, then back to success URL after payment
6. PAYG subscription created via API when user clicks "Start Pay-As-You-Go" (no upfront payment required)
7. Usage tracking implemented: After each interpretation, report usage to Lemon Squeezy API via `reportUsage()`
8. Webhook endpoint created at /api/webhooks/lemonsqueezy to handle events:
   - `subscription_created`: Create subscription in database, update user tier
   - `subscription_payment_success`: Reset usage counter for Pro users (monthly billing cycle)
   - `subscription_cancelled`: Downgrade user to trial tier (blocked until reactivation)
   - `usage_updated`: Log usage event for audit trail (optional)
9. User's lemonsqueezy_customer_id stored in database on first payment/subscription
10. Subscription record created/updated with lemonsqueezy_subscription_id, status, current_period_end
11. Successful Pro payment updates user tier to "pro" and resets messages_used_count to 0
12. PAYG subscription activation updates user tier to "payg" (no limit enforcement, usage tracked)
13. Webhook signature verification implemented (prevent fraudulent requests)
14. Lemon Squeezy integration tested in test mode with test cards
15. Error handling for failed payments displays user-friendly message
16. Monthly invoice generated by Lemon Squeezy for PAYG users: (interpretations_count × $0.50)
17. Usage tracking idempotent (duplicate reportUsage() calls don't double-charge)

---

## Tasks / Subtasks

- [ ] **Task 1: Install Lemon Squeezy SDK** (AC: 1)
  - [ ] Run: `npm install @lemonsqueezy/lemonsqueezy.js`
  - [ ] Verify package installed in `package.json`
  - [ ] Check current version (3.0+)
  - [ ] Review Lemon Squeezy SDK documentation: https://docs.lemonsqueezy.com/api

- [ ] **Task 2: Create Lemon Squeezy Account and Test/Production Stores** (AC: 1)
  - [ ] Create account at https://lemonsqueezy.com
  - [ ] Create **Test Mode** store: "TowerOfBabel (Test)"
  - [ ] Create **Production Mode** store: "TowerOfBabel"
  - [ ] Generate API keys for both stores:
    - Test mode: `LEMONSQUEEZY_API_KEY_TEST`
    - Production mode: `LEMONSQUEEZY_API_KEY`
  - [ ] Add API keys to `.env.local` and Vercel environment variables
  - [ ] Document store IDs for reference

- [ ] **Task 3: Create Lemon Squeezy Products and Variants** (AC: 2, 3)
  - [ ] Create **Pro Tier Product**:
    - Name: "TowerOfBabel Pro"
    - Price: $10/month
    - Billing cycle: Monthly
    - Description: "100 interpretations per month with automatic reset"
  - [ ] Create **PAYG Tier Product** (Usage-Based):
    - Name: "TowerOfBabel Pay-As-You-Go"
    - Base price: $0/month
    - Usage unit: "interpretation"
    - Usage unit price: $0.50
    - Billing cycle: Monthly (invoiced at month-end)
    - Description: "Pay only for what you use, billed monthly"
  - [ ] Document product IDs and variant IDs for environment variables
  - [ ] Test checkout flow in test mode for both products

- [ ] **Task 4: Add Lemon Squeezy Environment Variables** (AC: 1, 2, 3)
  - [ ] Update `.env.local.example`:
    ```bash
    # Lemon Squeezy Configuration
    LEMONSQUEEZY_API_KEY=your_production_api_key_here
    LEMONSQUEEZY_API_KEY_TEST=your_test_api_key_here
    LEMONSQUEEZY_STORE_ID=your_production_store_id
    LEMONSQUEEZY_STORE_ID_TEST=your_test_store_id
    LEMONSQUEEZY_PRO_VARIANT_ID=your_pro_variant_id
    LEMONSQUEEZY_PAYG_VARIANT_ID=your_payg_variant_id
    LEMONSQUEEZY_WEBHOOK_SECRET=your_webhook_signing_secret
    LEMONSQUEEZY_WEBHOOK_SECRET_TEST=your_test_webhook_signing_secret

    # Lemon Squeezy URLs
    NEXT_PUBLIC_URL=http://localhost:3000  # For local testing
    # Production: https://towerofbabel.com

    # Test mode flag (true/false)
    LEMONSQUEEZY_TEST_MODE=true  # Set to false in production
    ```
  - [ ] Document in README or lib/lemonsqueezy/README.md

- [ ] **Task 5: Create Lemon Squeezy Client** (AC: 1)
  - [ ] Create `/lib/lemonsqueezy/client.ts`:
    ```typescript
    import { lemonSqueezySetup } from '@lemonsqueezy/lemonsqueezy.js';

    /**
     * Initialize Lemon Squeezy API client
     * Automatically uses test or production mode based on environment
     */
    export function configureLemonSqueezy() {
      const isTestMode = process.env.LEMONSQUEEZY_TEST_MODE === 'true';
      const apiKey = isTestMode
        ? process.env.LEMONSQUEEZY_API_KEY_TEST
        : process.env.LEMONSQUEEZY_API_KEY;

      if (!apiKey) {
        throw new Error('Lemon Squeezy API key not configured');
      }

      lemonSqueezySetup({
        apiKey,
        onError: (error) => {
          console.error('Lemon Squeezy Error:', error);
          throw error;
        },
      });
    }

    export function getLemonSqueezyConfig() {
      const isTestMode = process.env.LEMONSQUEEZY_TEST_MODE === 'true';
      return {
        storeId: isTestMode
          ? process.env.LEMONSQUEEZY_STORE_ID_TEST!
          : process.env.LEMONSQUEEZY_STORE_ID!,
        proVariantId: process.env.LEMONSQUEEZY_PRO_VARIANT_ID!,
        paygVariantId: process.env.LEMONSQUEEZY_PAYG_VARIANT_ID!,
        webhookSecret: isTestMode
          ? process.env.LEMONSQUEEZY_WEBHOOK_SECRET_TEST!
          : process.env.LEMONSQUEEZY_WEBHOOK_SECRET!,
        isTestMode,
      };
    }
    ```
  - [ ] Add JSDoc documentation [Source: docs/architecture/16-coding-standards.md#jsdoc-for-public-apis]

- [ ] **Task 6: Create Database Migration for Lemon Squeezy Fields** (AC: 9, 10)
  - [ ] Modify `prisma/schema.prisma`:
    ```prisma
    model User {
      id                        String          @id @default(uuid())
      email                     String          @unique
      tier                      String          @default("trial") // 'trial' | 'payg' | 'pro'
      messages_used_count       Int             @default(0)
      messages_reset_date       DateTime?       // Pro tier reset date
      trial_start_date          DateTime        @default(now())

      // Lemon Squeezy Integration (NEW)
      lemonsqueezy_customer_id  String?         @unique
      subscriptions             Subscription[]  // Relation to subscriptions

      created_at                DateTime        @default(now())
      updated_at                DateTime        @updatedAt
    }

    model Subscription {
      id                              String   @id @default(uuid())
      user_id                         String
      user                            User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

      lemonsqueezy_subscription_id    String   @unique
      lemonsqueezy_order_id           String?
      lemonsqueezy_product_id         String
      lemonsqueezy_variant_id         String

      status                          String   // 'active', 'cancelled', 'expired', 'paused', 'past_due'
      tier                            String   // 'pro' or 'payg'
      renews_at                       DateTime?
      ends_at                         DateTime?
      trial_ends_at                   DateTime?
      billing_anchor                  Int?     // Day of month for billing

      created_at                      DateTime @default(now())
      updated_at                      DateTime @updatedAt

      @@index([user_id])
      @@index([status])
    }

    model LemonSqueezyEvent {
      id                      String   @id @default(uuid())
      lemonsqueezy_event_id   String   @unique  // Idempotency key
      event_type              String   // 'subscription_created', 'subscription_payment_success', etc.
      payload                 Json     // Full webhook payload
      processed_at            DateTime @default(now())

      @@index([lemonsqueezy_event_id])
    }
    ```
  - [ ] Run migration: `npx prisma migrate dev --name add-lemonsqueezy-integration`
  - [ ] Run Prisma generate: `npx prisma generate`
  - [ ] Verify migration applied successfully

- [ ] **Task 7: Create Pro Checkout Endpoint** (AC: 4, 5)
  - [ ] Create `/app/api/checkout/pro/route.ts`:
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { createClient } from '@/lib/auth/supabaseServer';
    import { createCheckout } from '@lemonsqueezy/lemonsqueezy.js';
    import { configureLemonSqueezy, getLemonSqueezyConfig } from '@/lib/lemonsqueezy/client';

    export async function POST(req: NextRequest) {
      // 1. Authentication
      const supabase = createClient();
      const { data: { user }, error } = await supabase.auth.getUser();
      if (error || !user) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      // 2. Configure Lemon Squeezy
      configureLemonSqueezy();
      const config = getLemonSqueezyConfig();

      // 3. Get user email from database
      const userRecord = await prisma.user.findUnique({
        where: { id: user.id },
        select: { email: true, lemonsqueezy_customer_id: true }
      });

      // 4. Create checkout session
      const successUrl = `${process.env.NEXT_PUBLIC_URL}/dashboard?upgrade=success`;
      const cancelUrl = `${process.env.NEXT_PUBLIC_URL}/dashboard?upgrade=cancelled`;

      const checkout = await createCheckout(config.storeId, config.proVariantId, {
        checkoutData: {
          email: userRecord.email,
          custom: {
            user_id: user.id  // Pass user_id to webhook
          }
        },
        checkoutOptions: {
          embed: false,  // Redirect to Lemon Squeezy hosted checkout
          media: true,
          logo: true
        },
        expiresAt: null,  // No expiration
        preview: config.isTestMode,  // Test mode preview
        testMode: config.isTestMode
      });

      if (checkout.error) {
        return NextResponse.json(
          { error: 'Failed to create checkout', details: checkout.error },
          { status: 500 }
        );
      }

      // 5. Return checkout URL
      return NextResponse.json({
        success: true,
        checkoutUrl: checkout.data.data.attributes.url
      });
    }
    ```
  - [ ] Add rate limiting (10 requests/min per user)
  - [ ] Add error logging
  - [ ] Add JSDoc documentation

- [ ] **Task 8: Create PAYG Subscription Endpoint** (AC: 6, 12)
  - [ ] Create `/app/api/subscription/payg/create/route.ts`:
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { createClient } from '@/lib/auth/supabaseServer';
    import { createSubscription } from '@lemonsqueezy/lemonsqueezy.js';
    import { configureLemonSqueezy, getLemonSqueezyConfig } from '@/lib/lemonsqueezy/client';

    export async function POST(req: NextRequest) {
      // 1. Authentication
      const supabase = createClient();
      const { data: { user }, error } = await supabase.auth.getUser();
      if (error || !user) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      // 2. Check if user already has PAYG subscription
      const existingSubscription = await prisma.subscription.findFirst({
        where: {
          user_id: user.id,
          tier: 'payg',
          status: 'active'
        }
      });

      if (existingSubscription) {
        return NextResponse.json(
          { error: 'User already has active PAYG subscription' },
          { status: 400 }
        );
      }

      // 3. Configure Lemon Squeezy
      configureLemonSqueezy();
      const config = getLemonSqueezyConfig();

      // 4. Get user email
      const userRecord = await prisma.user.findUnique({
        where: { id: user.id },
        select: { email: true }
      });

      // 5. Create usage-based subscription (no upfront payment)
      const subscription = await createSubscription(config.storeId, config.paygVariantId, {
        productOptions: {
          enabledVariants: [config.paygVariantId],
          redirectUrl: `${process.env.NEXT_PUBLIC_URL}/dashboard?payg=activated`
        },
        checkoutData: {
          email: userRecord.email,
          custom: {
            user_id: user.id
          }
        },
        preview: config.isTestMode,
        testMode: config.isTestMode
      });

      if (subscription.error) {
        return NextResponse.json(
          { error: 'Failed to create PAYG subscription', details: subscription.error },
          { status: 500 }
        );
      }

      // 6. Update user tier to PAYG immediately (no payment required)
      await prisma.user.update({
        where: { id: user.id },
        data: { tier: 'payg' }
      });

      // 7. Return success
      return NextResponse.json({
        success: true,
        message: 'PAYG subscription activated',
        tier: 'payg'
      });
    }
    ```
  - [ ] Add error handling
  - [ ] Add logging
  - [ ] Add JSDoc documentation

- [ ] **Task 9: Create Webhook Handler Endpoint** (AC: 8, 13)
  - [ ] Create `/app/api/webhooks/lemonsqueezy/route.ts`:
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import crypto from 'crypto';
    import { getLemonSqueezyConfig } from '@/lib/lemonsqueezy/client';
    import { handleSubscriptionCreated } from '@/lib/lemonsqueezy/webhookHandlers/subscriptionCreated';
    import { handleSubscriptionPaymentSuccess } from '@/lib/lemonsqueezy/webhookHandlers/subscriptionPaymentSuccess';
    import { handleSubscriptionCancelled } from '@/lib/lemonsqueezy/webhookHandlers/subscriptionCancelled';
    import { logger } from '@/lib/observability/logger';

    export async function POST(req: NextRequest) {
      // 1. Get raw body for signature verification
      const rawBody = await req.text();
      const signature = req.headers.get('x-signature');

      if (!signature) {
        return NextResponse.json({ error: 'Missing signature' }, { status: 401 });
      }

      // 2. Verify webhook signature
      const config = getLemonSqueezyConfig();
      const hmac = crypto.createHmac('sha256', config.webhookSecret);
      const digest = hmac.update(rawBody).digest('hex');

      if (digest !== signature) {
        logger.warn('Invalid webhook signature', { signature, digest });
        return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
      }

      // 3. Parse webhook payload
      const payload = JSON.parse(rawBody);
      const eventType = payload.meta.event_name;
      const eventId = payload.meta.custom_data?.event_id || payload.data.id;

      // 4. Check for duplicate events (idempotency)
      const existingEvent = await prisma.lemonSqueezyEvent.findUnique({
        where: { lemonsqueezy_event_id: eventId }
      });

      if (existingEvent) {
        logger.info('Duplicate webhook event, skipping', { eventId, eventType });
        return NextResponse.json({ received: true, duplicate: true });
      }

      // 5. Store event for idempotency
      await prisma.lemonSqueezyEvent.create({
        data: {
          lemonsqueezy_event_id: eventId,
          event_type: eventType,
          payload: payload
        }
      });

      // 6. Handle event based on type
      try {
        switch (eventType) {
          case 'subscription_created':
            await handleSubscriptionCreated(payload);
            break;
          case 'subscription_payment_success':
            await handleSubscriptionPaymentSuccess(payload);
            break;
          case 'subscription_cancelled':
          case 'subscription_expired':
            await handleSubscriptionCancelled(payload);
            break;
          case 'usage_updated':
            // Optional: Log usage updates
            logger.info('Usage updated', { payload });
            break;
          default:
            logger.warn('Unhandled webhook event', { eventType });
        }

        return NextResponse.json({ received: true });
      } catch (error) {
        logger.error('Webhook processing error', { error, eventType, eventId });
        return NextResponse.json(
          { error: 'Webhook processing failed' },
          { status: 500 }
        );
      }
    }
    ```
  - [ ] Add comprehensive error handling
  - [ ] Add structured logging for all webhook events
  - [ ] Add JSDoc documentation

- [ ] **Task 10: Create subscription_created Webhook Handler** (AC: 8, 9, 10, 11)
  - [ ] Create `/lib/lemonsqueezy/webhookHandlers/subscriptionCreated.ts`:
    ```typescript
    import { prisma } from '@/lib/db/prisma';
    import { logger } from '@/lib/observability/logger';

    export async function handleSubscriptionCreated(payload: any) {
      const subscription = payload.data.attributes;
      const customData = payload.meta.custom_data;
      const userId = customData.user_id;

      if (!userId) {
        throw new Error('Missing user_id in webhook payload');
      }

      // Determine tier from variant
      const variantId = subscription.variant_id.toString();
      const proVariantId = process.env.LEMONSQUEEZY_PRO_VARIANT_ID;
      const paygVariantId = process.env.LEMONSQUEEZY_PAYG_VARIANT_ID;

      let tier: 'pro' | 'payg';
      if (variantId === proVariantId) {
        tier = 'pro';
      } else if (variantId === paygVariantId) {
        tier = 'payg';
      } else {
        throw new Error(`Unknown variant ID: ${variantId}`);
      }

      // Create subscription record in database
      await prisma.$transaction(async (tx) => {
        // 1. Create subscription
        await tx.subscription.create({
          data: {
            user_id: userId,
            lemonsqueezy_subscription_id: subscription.id.toString(),
            lemonsqueezy_order_id: subscription.order_id?.toString(),
            lemonsqueezy_product_id: subscription.product_id.toString(),
            lemonsqueezy_variant_id: variantId,
            status: subscription.status,
            tier: tier,
            renews_at: subscription.renews_at ? new Date(subscription.renews_at) : null,
            ends_at: subscription.ends_at ? new Date(subscription.ends_at) : null,
            trial_ends_at: subscription.trial_ends_at ? new Date(subscription.trial_ends_at) : null,
            billing_anchor: subscription.billing_anchor
          }
        });

        // 2. Update user tier and customer ID
        await tx.user.update({
          where: { id: userId },
          data: {
            tier: tier,
            lemonsqueezy_customer_id: subscription.customer_id.toString(),
            // Pro tier: Reset usage and set reset date
            ...(tier === 'pro' && {
              messages_used_count: 0,
              messages_reset_date: subscription.renews_at ? new Date(subscription.renews_at) : null
            })
          }
        });
      });

      logger.info('Subscription created', {
        userId,
        tier,
        subscriptionId: subscription.id
      });
    }
    ```
  - [ ] Add error handling
  - [ ] Add JSDoc documentation

- [ ] **Task 11: Create subscription_payment_success Webhook Handler** (AC: 8, 11)
  - [ ] Create `/lib/lemonsqueezy/webhookHandlers/subscriptionPaymentSuccess.ts`:
    ```typescript
    export async function handleSubscriptionPaymentSuccess(payload: any) {
      const subscription = payload.data.attributes;
      const subscriptionId = subscription.id.toString();

      // Find subscription in database
      const dbSubscription = await prisma.subscription.findUnique({
        where: { lemonsqueezy_subscription_id: subscriptionId },
        include: { user: true }
      });

      if (!dbSubscription) {
        logger.warn('Subscription not found for payment success', { subscriptionId });
        return;
      }

      // Pro tier: Reset usage counter on payment success (monthly billing cycle)
      if (dbSubscription.tier === 'pro') {
        await prisma.$transaction(async (tx) => {
          // 1. Reset usage counter
          await tx.user.update({
            where: { id: dbSubscription.user_id },
            data: {
              messages_used_count: 0,
              messages_reset_date: subscription.renews_at ? new Date(subscription.renews_at) : null
            }
          });

          // 2. Update subscription renews_at
          await tx.subscription.update({
            where: { id: dbSubscription.id },
            data: {
              status: subscription.status,
              renews_at: subscription.renews_at ? new Date(subscription.renews_at) : null
            }
          });
        });

        logger.info('Pro subscription renewed, usage reset', {
          userId: dbSubscription.user_id,
          subscriptionId
        });
      }
    }
    ```
  - [ ] Add error handling
  - [ ] Add JSDoc documentation

- [ ] **Task 12: Create subscription_cancelled Webhook Handler** (AC: 8)
  - [ ] Create `/lib/lemonsqueezy/webhookHandlers/subscriptionCancelled.ts`:
    ```typescript
    export async function handleSubscriptionCancelled(payload: any) {
      const subscription = payload.data.attributes;
      const subscriptionId = subscription.id.toString();

      // Find subscription in database
      const dbSubscription = await prisma.subscription.findUnique({
        where: { lemonsqueezy_subscription_id: subscriptionId }
      });

      if (!dbSubscription) {
        logger.warn('Subscription not found for cancellation', { subscriptionId });
        return;
      }

      // Downgrade user to trial tier (blocked until reactivation)
      await prisma.$transaction(async (tx) => {
        // 1. Update subscription status
        await tx.subscription.update({
          where: { id: dbSubscription.id },
          data: {
            status: 'cancelled',
            ends_at: subscription.ends_at ? new Date(subscription.ends_at) : new Date()
          }
        });

        // 2. Downgrade user tier to trial
        await tx.user.update({
          where: { id: dbSubscription.user_id },
          data: {
            tier: 'trial',
            messages_reset_date: null  // Trial doesn't reset
          }
        });
      });

      logger.info('Subscription cancelled, user downgraded to trial', {
        userId: dbSubscription.user_id,
        subscriptionId
      });
    }
    ```
  - [ ] Add error handling
  - [ ] Add JSDoc documentation

- [ ] **Task 13: Implement Usage Reporting to Lemon Squeezy** (AC: 7, 16, 17)
  - [ ] Create `/lib/lemonsqueezy/usageReporting.ts`:
    ```typescript
    import { reportUsage } from '@lemonsqueezy/lemonsqueezy.js';
    import { configureLemonSqueezy } from '@/lib/lemonsqueezy/client';
    import { logger } from '@/lib/observability/logger';

    /**
     * Report interpretation usage to Lemon Squeezy for PAYG billing
     *
     * Idempotent: Uses unique idempotency key (interpretation_id) to prevent double-charging
     *
     * @param subscriptionId - Lemon Squeezy subscription ID
     * @param interpretationId - Unique interpretation ID (idempotency key)
     * @param quantity - Number of interpretations (always 1)
     */
    export async function reportInterpretationUsage(
      subscriptionId: string,
      interpretationId: string,
      quantity: number = 1
    ): Promise<void> {
      try {
        configureLemonSqueezy();

        // Report usage with idempotency key
        const result = await reportUsage(subscriptionId, {
          quantity: quantity,
          idempotencyKey: interpretationId  // Prevents duplicate charging
        });

        if (result.error) {
          throw new Error(`Failed to report usage: ${result.error.message}`);
        }

        logger.info('Usage reported to Lemon Squeezy', {
          subscriptionId,
          interpretationId,
          quantity
        });
      } catch (error) {
        logger.error('Usage reporting failed', {
          subscriptionId,
          interpretationId,
          error
        });
        // Don't throw - allow interpretation to succeed even if usage reporting fails
        // Lemon Squeezy has fallback mechanisms
      }
    }
    ```
  - [ ] Add JSDoc documentation
  - [ ] Add error handling (non-blocking)

- [ ] **Task 14: Integrate Usage Reporting into /api/interpret** (AC: 7, 17)
  - [ ] Modify `/app/api/interpret/route.ts`:
    ```typescript
    import { reportInterpretationUsage } from '@/lib/lemonsqueezy/usageReporting';

    export async function POST(req: NextRequest) {
      // ... existing authentication, validation, usage check, cost check, LLM call ...

      // After successful interpretation:
      const result = await llmProvider.interpret(...);

      // Track usage for PAYG users
      if (userRecord.tier === 'payg') {
        const subscription = await prisma.subscription.findFirst({
          where: {
            user_id: user.id,
            tier: 'payg',
            status: 'active'
          }
        });

        if (subscription) {
          // Report usage to Lemon Squeezy (non-blocking)
          await reportInterpretationUsage(
            subscription.lemonsqueezy_subscription_id,
            interpretationRecord.id,  // Unique idempotency key
            1  // One interpretation
          );
        }
      }

      // ... rest of response ...
    }
    ```
  - [ ] Add error handling (don't block interpretation if usage reporting fails)
  - [ ] Add logging for usage reporting success/failure

- [ ] **Task 15: Update UpgradeModal CTA Handlers** (AC: 4, 6)
  - [ ] Modify `/components/features/upgrade/UpgradeModal.tsx`:
    ```typescript
    import { useRouter } from 'next/navigation';
    import { useToast } from '@/components/ui/use-toast';

    export function UpgradeModal({ ...props }: UpgradeModalProps) {
      const router = useRouter();
      const { toast } = useToast();
      const [loading, setLoading] = useState<'pro' | 'payg' | null>(null);

      const handleSubscribeToPro = async () => {
        setLoading('pro');
        try {
          // Call checkout endpoint
          const response = await fetch('/api/checkout/pro', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });

          if (!response.ok) {
            throw new Error('Failed to create checkout session');
          }

          const data = await response.json();

          // Redirect to Lemon Squeezy checkout
          window.location.href = data.checkoutUrl;
        } catch (error) {
          toast({
            title: 'Error',
            description: 'Failed to start subscription. Please try again.',
            variant: 'destructive'
          });
          setLoading(null);
        }
      };

      const handleStartPayAsYouGo = async () => {
        setLoading('payg');
        try {
          // Call PAYG subscription endpoint
          const response = await fetch('/api/subscription/payg/create', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });

          if (!response.ok) {
            throw new Error('Failed to activate Pay-As-You-Go');
          }

          const data = await response.json();

          // Show success message
          toast({
            title: 'Pay-As-You-Go Activated',
            description: 'You can now use interpretations. Billed monthly at $0.50 per use.',
            variant: 'default'
          });

          // Close modal and refresh
          onOpenChange(false);
          router.refresh();
        } catch (error) {
          toast({
            title: 'Error',
            description: 'Failed to activate Pay-As-You-Go. Please try again.',
            variant: 'destructive'
          });
          setLoading(null);
        }
      };

      return (
        <Dialog open={open} onOpenChange={onOpenChange}>
          {/* ... modal content ... */}
          <PricingCard
            tier="pro"
            onCtaClick={handleSubscribeToPro}
            disabled={loading !== null}
            loading={loading === 'pro'}
          />
          <PricingCard
            tier="payg"
            onCtaClick={handleStartPayAsYouGo}
            disabled={loading !== null}
            loading={loading === 'payg'}
          />
        </Dialog>
      );
    }
    ```
  - [ ] Add loading spinners to CTA buttons
  - [ ] Add error handling with user-friendly messages

- [ ] **Task 16: Create Checkout Success/Cancel Pages** (AC: 5)
  - [ ] Create `/app/(dashboard)/checkout/success/page.tsx`:
    ```tsx
    import { redirect } from 'next/navigation';
    import { createClient } from '@/lib/auth/supabaseServer';

    export default async function CheckoutSuccessPage() {
      const supabase = createClient();
      const { data: { user } } = await supabase.auth.getUser();

      if (!user) {
        redirect('/signin');
      }

      return (
        <div className="container max-w-2xl mx-auto px-4 py-16">
          <div className="text-center">
            <h1 className="text-3xl font-bold mb-4">🎉 Subscription Activated!</h1>
            <p className="text-lg text-muted-foreground mb-8">
              Your Pro subscription is now active. You have 100 interpretations per month.
            </p>
            <a
              href="/dashboard"
              className="inline-block px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
            >
              Go to Dashboard
            </a>
          </div>
        </div>
      );
    }
    ```
  - [ ] Create `/app/(dashboard)/checkout/cancelled/page.tsx` with similar structure
  - [ ] Add responsive design
  - [ ] Add session checks to verify user is authenticated

- [ ] **Task 17: Write Unit Tests for Lemon Squeezy Client**
  - [ ] Create `/tests/unit/lib/lemonsqueezy/client.test.ts`
  - [ ] Test: configureLemonSqueezy() sets up API client
  - [ ] Test: getLemonSqueezyConfig() returns correct config for test mode
  - [ ] Test: getLemonSqueezyConfig() returns correct config for production mode
  - [ ] Test: Throws error if API key not configured
  - [ ] Mock environment variables
  - [ ] Use Vitest

- [ ] **Task 18: Write Unit Tests for Webhook Handlers**
  - [ ] Create `/tests/unit/lib/lemonsqueezy/webhookHandlers/subscriptionCreated.test.ts`
  - [ ] Test: Creates subscription and updates user tier to 'pro'
  - [ ] Test: Creates subscription and updates user tier to 'payg'
  - [ ] Test: Resets usage counter for Pro subscriptions
  - [ ] Test: Sets customer_id on user record
  - [ ] Create similar tests for subscriptionPaymentSuccess and subscriptionCancelled handlers
  - [ ] Mock Prisma with different scenarios
  - [ ] Use Vitest

- [ ] **Task 19: Write Integration Tests for Checkout Endpoints**
  - [ ] Create `/tests/integration/api/checkout/pro.test.ts`
  - [ ] Test: Returns 401 for unauthenticated requests
  - [ ] Test: Creates checkout session for authenticated user
  - [ ] Test: Returns checkout URL in response
  - [ ] Test: Checkout URL contains correct variant ID
  - [ ] Mock Lemon Squeezy createCheckout API
  - [ ] Use Vitest + Supertest

- [ ] **Task 20: Write Integration Tests for Webhook Endpoint**
  - [ ] Create `/tests/integration/api/webhooks/lemonsqueezy.test.ts`
  - [ ] Test: Returns 401 for missing signature
  - [ ] Test: Returns 401 for invalid signature
  - [ ] Test: Processes subscription_created event
  - [ ] Test: Processes subscription_payment_success event
  - [ ] Test: Processes subscription_cancelled event
  - [ ] Test: Idempotency - duplicate events skipped
  - [ ] Mock webhook payloads with valid signatures
  - [ ] Use Vitest + Supertest

- [ ] **Task 21: Write Integration Tests for Usage Reporting**
  - [ ] Create `/tests/integration/lemonsqueezy/usageReporting.test.ts`
  - [ ] Test: Reports usage to Lemon Squeezy for PAYG user
  - [ ] Test: Idempotency - same interpretation_id doesn't double-charge
  - [ ] Test: Non-blocking - interpretation succeeds even if reporting fails
  - [ ] Test: No usage reporting for Pro or trial users
  - [ ] Mock Lemon Squeezy reportUsage API
  - [ ] Use Vitest

- [ ] **Task 22: Manual Testing with Lemon Squeezy Test Mode**
  - [ ] Set LEMONSQUEEZY_TEST_MODE=true
  - [ ] Create trial user and click "Subscribe to Pro"
  - [ ] Verify redirects to Lemon Squeezy checkout (test mode)
  - [ ] Complete checkout with test card: 4242 4242 4242 4242
  - [ ] Verify redirects back to success page
  - [ ] Verify webhook fires subscription_created event
  - [ ] Verify user tier updated to 'pro' in database
  - [ ] Verify usage counter reset to 0
  - [ ] Test PAYG activation (no payment required)
  - [ ] Verify user tier updated to 'payg'
  - [ ] Submit interpretation → verify usage reported to Lemon Squeezy
  - [ ] Check Lemon Squeezy dashboard for usage event

- [ ] **Task 23: Manual Testing of Webhook Signature Verification**
  - [ ] Use Lemon Squeezy webhook tester or curl
  - [ ] Send webhook with valid signature → verify 200 response
  - [ ] Send webhook with invalid signature → verify 401 response
  - [ ] Send duplicate webhook (same event_id) → verify duplicate detected
  - [ ] Check database for LemonSqueezyEvent records
  - [ ] Verify idempotency prevents duplicate processing

- [ ] **Task 24: Manual Testing of Subscription Cancellation**
  - [ ] Create Pro user in test mode
  - [ ] Cancel subscription in Lemon Squeezy dashboard
  - [ ] Verify webhook fires subscription_cancelled event
  - [ ] Verify user tier downgraded to 'trial'
  - [ ] Verify user cannot interpret (blocked by trial limit)
  - [ ] Verify subscription status updated to 'cancelled' in database

- [ ] **Task 25: Build and Lint Validation**
  - [ ] Run TypeScript compilation: `npx tsc --noEmit`
  - [ ] Verify no TypeScript errors
  - [ ] Run ESLint: `npm run lint`
  - [ ] Verify no ESLint errors (warnings acceptable)
  - [ ] Run unit tests: `npm test tests/unit`
  - [ ] Run integration tests: `npm test tests/integration`
  - [ ] Verify all tests pass
  - [ ] Check bundle size impact (< 300KB total goal)

- [ ] **Task 26: Commit Changes**
  - [ ] Stage all changes: `git add .`
  - [ ] Commit with conventional commit message: `feat(payments): integrate Lemon Squeezy for subscriptions and metered billing (Story 3.4)` [Source: docs/architecture/16-coding-standards.md#conventional-commits]
  - [ ] Push to GitHub: `git push origin main`
  - [ ] Verify CI pipeline passes

---

## Dev Notes

### Story Context and Integration

**This story integrates Lemon Squeezy payment processing to enable Pro subscriptions and Pay-As-You-Go metered billing.**

**Integration Flow:**
- Story 3.1: Backend usage limit enforcement (DONE)
- Story 3.2: Usage indicator + notifications (APPROVED)
- Story 3.3: Upgrade modal with pricing tiers (READY FOR IMPLEMENTATION)
- **Story 3.4 (THIS STORY):** Lemon Squeezy payment integration
- Story 3.5: Billing portal and subscription management

**Key Insights from Story 3.3:**
- UpgradeModal has placeholder CTA handlers ready for Lemon Squeezy integration
- "Subscribe to Pro" button should redirect to Lemon Squeezy Checkout
- "Start Pay-As-You-Go" button should activate PAYG subscription (no upfront payment)
- upgradeModalStore tracks trigger source for analytics

**What Story 3.4 Adds:**
- ✨ **NEW:** Lemon Squeezy SDK integration (@lemonsqueezy/lemonsqueezy.js)
- ✨ **NEW:** Pro tier checkout session creation
- ✨ **NEW:** PAYG tier usage-based subscription creation (no upfront payment)
- ✨ **NEW:** Webhook endpoint for subscription events (subscription_created, subscription_payment_success, subscription_cancelled)
- ✨ **NEW:** Idempotent webhook processing (LemonSqueezyEvent table)
- ✨ **NEW:** Usage reporting to Lemon Squeezy for PAYG users ($0.50 per interpretation)
- ✨ **NEW:** Database tables: Subscription, LemonSqueezyEvent
- ✨ **NEW:** Checkout success/cancel pages

**What Story 3.5 Will Add:**
- Billing portal link for users to manage subscriptions
- View billing history and invoices
- Update payment method
- Cancel subscription via Customer Portal

---

### CRITICAL Architectural Patterns

#### Idempotent Webhook Processing

**Pattern:** Prevent duplicate webhook processing using event_id as idempotency key.

```typescript
// /app/api/webhooks/lemonsqueezy/route.ts
export async function POST(req: NextRequest) {
  const payload = JSON.parse(rawBody);
  const eventId = payload.meta.custom_data?.event_id || payload.data.id;

  // Check for duplicate events
  const existingEvent = await prisma.lemonSqueezyEvent.findUnique({
    where: { lemonsqueezy_event_id: eventId }
  });

  if (existingEvent) {
    logger.info('Duplicate webhook event, skipping', { eventId });
    return NextResponse.json({ received: true, duplicate: true });
  }

  // Store event before processing
  await prisma.lemonSqueezyEvent.create({
    data: {
      lemonsqueezy_event_id: eventId,
      event_type: eventType,
      payload: payload
    }
  });

  // Process event
  await handleWebhookEvent(payload);
}
```

**Why This Pattern:**
- Webhooks may be delivered multiple times (network retries, Lemon Squeezy retries)
- Duplicate processing could double-charge users or cause data corruption
- LemonSqueezyEvent table acts as idempotency log
- Critical for subscription_created (prevents duplicate subscription records)
- Critical for subscription_payment_success (prevents double usage resets)

[Source: docs/architecture/6-components.md#component-5-lemon-squeezy-integration-service]

---

#### Webhook Signature Verification

**Pattern:** Verify HMAC signature to prevent fraudulent webhook requests.

```typescript
import crypto from 'crypto';

export async function POST(req: NextRequest) {
  // 1. Get raw body (required for signature verification)
  const rawBody = await req.text();
  const signature = req.headers.get('x-signature');

  if (!signature) {
    return NextResponse.json({ error: 'Missing signature' }, { status: 401 });
  }

  // 2. Compute HMAC signature
  const config = getLemonSqueezyConfig();
  const hmac = crypto.createHmac('sha256', config.webhookSecret);
  const digest = hmac.update(rawBody).digest('hex');

  // 3. Compare signatures
  if (digest !== signature) {
    logger.warn('Invalid webhook signature', { signature, digest });
    return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
  }

  // 4. Safe to process webhook
  const payload = JSON.parse(rawBody);
  // ...
}
```

**Why This Pattern:**
- Prevents malicious actors from faking webhooks
- Ensures webhooks actually come from Lemon Squeezy
- Critical for financial operations (subscription creation, cancellation)
- Required by PCI compliance (NFR10)

**Implementation Note:**
- Use raw body (text) for signature verification, NOT parsed JSON
- Lemon Squeezy uses SHA-256 HMAC with webhook secret
- Signature in `x-signature` header

[Source: docs/architecture/6-components.md#component-5-lemon-squeezy-integration-service]

---

### Lemon Squeezy Configuration

**Test Mode vs Production Mode:**

```typescript
// /lib/lemonsqueezy/client.ts
export function configureLemonSqueezy() {
  const isTestMode = process.env.LEMONSQUEEZY_TEST_MODE === 'true';
  const apiKey = isTestMode
    ? process.env.LEMONSQUEEZY_API_KEY_TEST
    : process.env.LEMONSQUEEZY_API_KEY;

  lemonSqueezySetup({
    apiKey,
    onError: (error) => {
      console.error('Lemon Squeezy Error:', error);
      throw error;
    },
  });
}
```

**Environment Variables:**
```bash
# Test Mode Configuration
LEMONSQUEEZY_TEST_MODE=true
LEMONSQUEEZY_API_KEY_TEST=your_test_api_key
LEMONSQUEEZY_STORE_ID_TEST=your_test_store_id
LEMONSQUEEZY_WEBHOOK_SECRET_TEST=your_test_webhook_secret

# Production Mode Configuration
LEMONSQUEEZY_TEST_MODE=false  # Set in production
LEMONSQUEEZY_API_KEY=your_production_api_key
LEMONSQUEEZY_STORE_ID=your_production_store_id
LEMONSQUEEZY_WEBHOOK_SECRET=your_production_webhook_secret

# Product Configuration
LEMONSQUEEZY_PRO_VARIANT_ID=12345  # Pro tier variant
LEMONSQUEEZY_PAYG_VARIANT_ID=67890  # PAYG tier variant
```

**Why Test Mode:**
- Develop and test without real charges
- Use test cards: 4242 4242 4242 4242
- Separate webhook endpoints for test/production
- Easy to reset test data

**Setting Up Test Mode:**
1. Create separate test store in Lemon Squeezy
2. Create test products and variants
3. Generate test API key
4. Set LEMONSQUEEZY_TEST_MODE=true in .env.local
5. Test checkout flow with test card
6. Verify webhooks fire in test mode

[Source: docs/architecture/3-tech-stack.md]

---

### Pro Tier Checkout Flow

**User Journey:**
1. User clicks "Subscribe to Pro" in UpgradeModal
2. Frontend calls `/api/checkout/pro` (POST)
3. Backend creates Lemon Squeezy checkout session
4. Backend returns `checkoutUrl`
5. Frontend redirects to Lemon Squeezy hosted checkout page
6. User enters payment details (or uses saved card)
7. Lemon Squeezy processes payment
8. Lemon Squeezy sends `subscription_created` webhook to `/api/webhooks/lemonsqueezy`
9. Webhook handler creates subscription record, updates user tier to 'pro', resets usage
10. Lemon Squeezy redirects back to `/checkout/success`
11. User sees success message, redirects to dashboard

**Checkout Session Creation:**

```typescript
// /app/api/checkout/pro/route.ts
const checkout = await createCheckout(config.storeId, config.proVariantId, {
  checkoutData: {
    email: userRecord.email,
    custom: {
      user_id: user.id  // Pass user_id to webhook
    }
  },
  checkoutOptions: {
    embed: false,  // Redirect to hosted checkout (not embedded)
    media: true,   // Show product media
    logo: true     // Show TowerOfBabel logo
  },
  expiresAt: null,  // No expiration
  preview: config.isTestMode,  // Preview mode for testing
  testMode: config.isTestMode
});

// Returns: { data: { attributes: { url: 'https://checkout.lemonsqueezy.com/...' } } }
```

**Success/Cancel URLs:**
```typescript
// Configured in Lemon Squeezy product settings or checkout options
const successUrl = `${process.env.NEXT_PUBLIC_URL}/checkout/success`;
const cancelUrl = `${process.env.NEXT_PUBLIC_URL}/checkout/cancelled`;
```

**Why Hosted Checkout:**
- PCI compliant (Lemon Squeezy handles card details)
- No credit card fields in TowerOfBabel UI
- Supports multiple payment methods (cards, Apple Pay, Google Pay)
- Lemon Squeezy handles 3D Secure, fraud detection, VAT collection

[Source: Epic 3 AC 4, 5]

---

### PAYG Tier Activation Flow

**User Journey:**
1. User clicks "Start Pay-As-You-Go" in UpgradeModal
2. Frontend calls `/api/subscription/payg/create` (POST)
3. Backend creates Lemon Squeezy usage-based subscription (no upfront payment)
4. Backend updates user tier to 'payg' immediately
5. Frontend shows success toast, refreshes page
6. User can now interpret (usage tracked, billed monthly)

**PAYG Subscription Creation:**

```typescript
// /app/api/subscription/payg/create/route.ts
const subscription = await createSubscription(config.storeId, config.paygVariantId, {
  productOptions: {
    enabledVariants: [config.paygVariantId],
    redirectUrl: `${process.env.NEXT_PUBLIC_URL}/dashboard?payg=activated`
  },
  checkoutData: {
    email: userRecord.email,
    custom: {
      user_id: user.id
    }
  },
  preview: config.isTestMode,
  testMode: config.isTestMode
});

// No payment required upfront - user billed at month-end
```

**Why No Upfront Payment:**
- PAYG is usage-based ($0/month base + $0.50 per interpretation)
- User only pays for what they use
- Billed monthly at end of billing cycle
- Lowers barrier to entry vs Pro ($10 upfront)

**Usage Reporting:**
```typescript
// After each interpretation for PAYG users:
await reportInterpretationUsage(
  subscription.lemonsqueezy_subscription_id,
  interpretationRecord.id,  // Idempotency key
  1  // Quantity
);
```

**Monthly Billing:**
- Lemon Squeezy aggregates usage events
- Generates invoice at month-end: (interpretation_count × $0.50)
- Sends `subscription_payment_success` webhook after payment
- User can view invoice in Billing Portal (Story 3.5)

[Source: Epic 3 AC 6, 7, 16, 17]

---

### Webhook Event Handling

**subscription_created (AC: 8, 9, 10, 11)**

Triggered when user completes checkout (Pro) or activates PAYG.

```typescript
// Payload structure
{
  meta: {
    event_name: 'subscription_created',
    custom_data: {
      user_id: 'user-uuid'  // Passed from checkout
    }
  },
  data: {
    id: '12345',
    attributes: {
      customer_id: '67890',
      product_id: '123',
      variant_id: '456',  // Pro or PAYG variant
      status: 'active',
      renews_at: '2025-11-24T00:00:00Z',
      // ...
    }
  }
}
```

**Handler Actions:**
1. Create Subscription record in database
2. Update user.tier to 'pro' or 'payg'
3. Update user.lemonsqueezy_customer_id (first time only)
4. If Pro: Reset messages_used_count to 0, set messages_reset_date
5. If PAYG: No usage reset (unlimited, billed per use)

**subscription_payment_success (AC: 8, 11)**

Triggered on recurring Pro payments (monthly billing cycle).

```typescript
// Handler Actions (Pro tier only):
1. Reset messages_used_count to 0
2. Update messages_reset_date to next billing date
3. Update subscription.renews_at
```

**subscription_cancelled (AC: 8)**

Triggered when user cancels subscription or payment fails repeatedly.

```typescript
// Handler Actions:
1. Update subscription.status to 'cancelled'
2. Downgrade user.tier to 'trial'
3. Set subscription.ends_at
// User blocked by trial limits (10 messages, 14 days)
```

**usage_updated (AC: 8)**

Triggered when usage is reported for PAYG users (optional logging).

```typescript
// Handler Actions (optional):
1. Log usage event for audit trail
2. No database updates needed (Lemon Squeezy tracks usage)
```

[Source: Epic 3 AC 8]

---

### Usage Reporting Idempotency (AC: 17)

**Problem:** Duplicate usage reports could double-charge PAYG users.

**Solution:** Use interpretation_id as idempotency key.

```typescript
// /lib/lemonsqueezy/usageReporting.ts
export async function reportInterpretationUsage(
  subscriptionId: string,
  interpretationId: string,  // Unique ID from database
  quantity: number = 1
): Promise<void> {
  const result = await reportUsage(subscriptionId, {
    quantity: quantity,
    idempotencyKey: interpretationId  // Prevents duplicate charging
  });

  // Lemon Squeezy deduplicates by idempotencyKey
  // Same interpretationId sent twice = charged once
}
```

**Why This Works:**
- Each interpretation has unique ID in database
- Same ID used for both interpretation record AND usage reporting
- Lemon Squeezy API deduplicates based on idempotencyKey
- Safe to retry usage reporting on failure (won't double-charge)

**Error Handling:**
```typescript
try {
  await reportInterpretationUsage(...);
} catch (error) {
  logger.error('Usage reporting failed', { error });
  // Don't throw - allow interpretation to succeed
  // Lemon Squeezy has fallback mechanisms and reconciliation
}
```

**Non-Blocking:**
- Usage reporting failure doesn't block interpretation
- User gets interpretation result even if reporting fails
- Lemon Squeezy can reconcile missing usage events

[Source: Epic 3 AC 17]

---

### Database Schema Changes

**New Tables:**

**1. Subscription**
```prisma
model Subscription {
  id                              String   @id @default(uuid())
  user_id                         String
  user                            User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  lemonsqueezy_subscription_id    String   @unique
  lemonsqueezy_order_id           String?
  lemonsqueezy_product_id         String
  lemonsqueezy_variant_id         String

  status                          String   // 'active', 'cancelled', 'expired', 'paused', 'past_due'
  tier                            String   // 'pro' or 'payg'
  renews_at                       DateTime?
  ends_at                         DateTime?
  trial_ends_at                   DateTime?
  billing_anchor                  Int?     // Day of month for billing

  created_at                      DateTime @default(now())
  updated_at                      DateTime @updatedAt

  @@index([user_id])
  @@index([status])
}
```

**2. LemonSqueezyEvent (Idempotency Log)**
```prisma
model LemonSqueezyEvent {
  id                      String   @id @default(uuid())
  lemonsqueezy_event_id   String   @unique  // Idempotency key
  event_type              String   // 'subscription_created', etc.
  payload                 Json     // Full webhook payload
  processed_at            DateTime @default(now())

  @@index([lemonsqueezy_event_id])
}
```

**Modified Tables:**

**User**
```prisma
model User {
  id                        String          @id @default(uuid())
  email                     String          @unique
  tier                      String          @default("trial")
  messages_used_count       Int             @default(0)
  messages_reset_date       DateTime?

  // NEW FIELDS
  lemonsqueezy_customer_id  String?         @unique
  subscriptions             Subscription[]  // Relation

  // ... existing fields
}
```

**Why These Changes:**
- Subscription table: Tracks Lemon Squeezy subscription data
- LemonSqueezyEvent table: Prevents duplicate webhook processing
- lemonsqueezy_customer_id: Links user to Lemon Squeezy customer record
- Cascade delete: Deleting user deletes subscriptions (GDPR compliance)

[Source: docs/architecture/4-data-models.md, docs/architecture/9-database-schema.md]

---

### File Locations and Project Structure

**Files to Create:**
```
/lib/lemonsqueezy/
  ├── client.ts                              # CREATE: Lemon Squeezy SDK setup
  ├── usageReporting.ts                      # CREATE: Usage reporting for PAYG
  └── webhookHandlers/
      ├── subscriptionCreated.ts             # CREATE: subscription_created handler
      ├── subscriptionPaymentSuccess.ts      # CREATE: subscription_payment_success handler
      └── subscriptionCancelled.ts           # CREATE: subscription_cancelled handler

/app/api/checkout/pro/
  └── route.ts                               # CREATE: Pro checkout endpoint

/app/api/subscription/payg/create/
  └── route.ts                               # CREATE: PAYG subscription endpoint

/app/api/webhooks/lemonsqueezy/
  └── route.ts                               # CREATE: Webhook handler endpoint

/app/(dashboard)/checkout/
  ├── success/page.tsx                       # CREATE: Checkout success page
  └── cancelled/page.tsx                     # CREATE: Checkout cancelled page

/prisma/
  └── migrations/                            # CREATE: add-lemonsqueezy-integration migration

/tests/unit/lib/lemonsqueezy/
  ├── client.test.ts                         # CREATE: Client tests
  └── webhookHandlers/
      ├── subscriptionCreated.test.ts        # CREATE: Handler tests
      ├── subscriptionPaymentSuccess.test.ts
      └── subscriptionCancelled.test.ts

/tests/integration/api/
  ├── checkout/
  │   └── pro.test.ts                        # CREATE: Checkout endpoint tests
  └── webhooks/
      └── lemonsqueezy.test.ts               # CREATE: Webhook endpoint tests

/tests/integration/lemonsqueezy/
  └── usageReporting.test.ts                 # CREATE: Usage reporting tests
```

**Files to Modify:**
```
/components/features/upgrade/
  └── UpgradeModal.tsx                       # MODIFY: Replace placeholder CTAs with real handlers

/app/api/interpret/
  └── route.ts                               # MODIFY: Add usage reporting for PAYG users

/prisma/
  └── schema.prisma                          # MODIFY: Add Subscription, LemonSqueezyEvent tables

/.env.local.example                          # MODIFY: Add Lemon Squeezy environment variables

/package.json                                # MODIFY: Add @lemonsqueezy/lemonsqueezy.js
```

[Source: docs/architecture/12-unified-project-structure.md]

---

### Relevant Source Tree

```
towerofbabel/
├── app/
│   ├── (dashboard)/
│   │   └── checkout/
│   │       ├── success/page.tsx            # CREATE: Success page
│   │       └── cancelled/page.tsx          # CREATE: Cancelled page
│   └── api/
│       ├── checkout/
│       │   └── pro/
│       │       └── route.ts                # CREATE: Pro checkout endpoint
│       ├── subscription/
│       │   └── payg/
│       │       └── create/
│       │           └── route.ts            # CREATE: PAYG subscription endpoint
│       ├── webhooks/
│       │   └── lemonsqueezy/
│       │       └── route.ts                # CREATE: Webhook handler
│       └── interpret/
│           └── route.ts                    # MODIFY: Add usage reporting
├── components/
│   └── features/
│       └── upgrade/
│           └── UpgradeModal.tsx            # MODIFY: Replace placeholder CTAs
├── lib/
│   ├── lemonsqueezy/
│   │   ├── client.ts                       # CREATE: SDK setup
│   │   ├── usageReporting.ts               # CREATE: Usage reporting
│   │   └── webhookHandlers/
│   │       ├── subscriptionCreated.ts      # CREATE
│   │       ├── subscriptionPaymentSuccess.ts # CREATE
│   │       └── subscriptionCancelled.ts    # CREATE
│   └── db/
│       └── prisma.ts                       # EXISTING: Use for transactions
├── prisma/
│   ├── schema.prisma                       # MODIFY: Add Subscription, LemonSqueezyEvent
│   └── migrations/                         # CREATE: add-lemonsqueezy-integration
├── tests/
│   ├── unit/
│   │   └── lib/
│   │       └── lemonsqueezy/
│   │           ├── client.test.ts          # CREATE
│   │           └── webhookHandlers/
│   │               ├── subscriptionCreated.test.ts
│   │               ├── subscriptionPaymentSuccess.test.ts
│   │               └── subscriptionCancelled.test.ts
│   └── integration/
│       ├── api/
│       │   ├── checkout/
│       │   │   └── pro.test.ts             # CREATE
│       │   └── webhooks/
│       │       └── lemonsqueezy.test.ts    # CREATE
│       └── lemonsqueezy/
│           └── usageReporting.test.ts      # CREATE
├── .env.local.example                      # MODIFY: Add Lemon Squeezy config
└── package.json                            # MODIFY: Add @lemonsqueezy/lemonsqueezy.js
```

---

### Testing Strategy

**Unit Tests (Target: 80% Coverage):**

1. **Lemon Squeezy Client Tests** (`client.test.ts`):
   - configureLemonSqueezy() sets up API client
   - getLemonSqueezyConfig() returns correct config for test/production mode
   - Throws error if API key not configured

2. **Webhook Handler Tests** (3 test files):
   - subscriptionCreated: Creates subscription, updates tier, resets usage (Pro)
   - subscriptionPaymentSuccess: Resets usage for Pro users
   - subscriptionCancelled: Downgrades user to trial
   - Mock Prisma transactions

**Integration Tests (Target: 60% Coverage):**

3. **Checkout Endpoint Tests** (`pro.test.ts`):
   - Returns 401 for unauthenticated requests
   - Creates checkout session for authenticated user
   - Returns checkout URL
   - Mock Lemon Squeezy createCheckout API

4. **Webhook Endpoint Tests** (`lemonsqueezy.test.ts`):
   - Returns 401 for missing/invalid signature
   - Processes subscription_created, subscription_payment_success, subscription_cancelled
   - Idempotency: Duplicate events skipped
   - Mock webhook payloads with valid signatures

5. **Usage Reporting Tests** (`usageReporting.test.ts`):
   - Reports usage to Lemon Squeezy for PAYG user
   - Idempotency: Same interpretation_id doesn't double-charge
   - Non-blocking: Interpretation succeeds even if reporting fails
   - Mock Lemon Squeezy reportUsage API

**Manual Testing Scenarios:**

6. **Pro Subscription Flow (Test Mode):**
   - Click "Subscribe to Pro" → redirects to Lemon Squeezy checkout
   - Complete checkout with test card (4242 4242 4242 4242)
   - Verify redirect to success page
   - Verify webhook fires, user tier updated to 'pro'
   - Verify usage counter reset to 0

7. **PAYG Activation Flow:**
   - Click "Start Pay-As-You-Go" → no payment required
   - Verify tier updated to 'payg' immediately
   - Submit interpretation → verify usage reported to Lemon Squeezy
   - Check Lemon Squeezy dashboard for usage event

8. **Webhook Security Testing:**
   - Send webhook with valid signature → 200 response
   - Send webhook with invalid signature → 401 response
   - Send duplicate webhook → duplicate detected

9. **Subscription Cancellation:**
   - Cancel Pro subscription in Lemon Squeezy dashboard
   - Verify webhook fires, user downgraded to trial
   - Verify user blocked by trial limits

**Testing Framework:**
- **Unit Tests:** Vitest + mocked Lemon Squeezy SDK
- **Integration Tests:** Vitest + Supertest + mocked Lemon Squeezy API
- **Manual Tests:** Lemon Squeezy test mode + test cards

[Source: docs/architecture/16-coding-standards.md#testing-standards, docs/architecture/3-tech-stack.md]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Story created with Lemon Squeezy integration for subscriptions and metered billing | Scrum Master (Bob) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_

---
