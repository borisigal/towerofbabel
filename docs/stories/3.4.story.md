# Story 3.4: Integrate Lemon Squeezy for Subscriptions and Metered Billing

<!-- Powered by BMAD™ Core -->

## Status

**Ready for Implementation**

**PO Validation Date:** 2025-10-24
**Validation Score:** 9.5/10 (Excellent after comprehensive test enhancements)
**Implementation Notes:**
- CRITICAL: This is a payment integration - comprehensive testing is mandatory
- Test coverage: 33 test tasks out of 50 total tasks (66% task coverage)
- Comprehensive test suite targets 95%+ code coverage for all payment flows
- Coverage includes: unit tests, integration tests, E2E tests, security tests, performance tests
- All payment flows, failure scenarios, security, edge cases, concurrency, and error recovery covered
- Manual testing required in both test mode and production before launch
- Production readiness checklist included (Task 50)

---

## Story

**As a** user,
**I want** to subscribe to Pro tier or pay-per-use with monthly billing,
**so that** I can continue using TowerOfBabel after my trial ends.

---

## Acceptance Criteria

1. Lemon Squeezy account created and configured (test mode and production mode)
2. Lemon Squeezy Product created for Pro tier: "$10/month recurring subscription"
3. Lemon Squeezy Usage-Based Subscription created for PAYG tier: "$0/month base + $0.50 per interpretation metered"
4. Lemon Squeezy Checkout session created when user clicks "Subscribe to Pro"
5. Checkout session redirects to Lemon Squeezy hosted page, then back to success URL after payment
6. PAYG subscription created via API when user clicks "Start Pay-As-You-Go" (no upfront payment required)
7. Usage tracking implemented: After each interpretation, report usage to Lemon Squeezy API via `reportUsage()`
8. Webhook endpoint created at /api/webhooks/lemonsqueezy to handle events:
   - `subscription_created`: Create subscription in database, update user tier
   - `subscription_payment_success`: Reset usage counter for Pro users (monthly billing cycle)
   - `subscription_cancelled`: Downgrade user to trial tier (blocked until reactivation)
   - `usage_updated`: Log usage event for audit trail (optional)
9. User's lemonsqueezy_customer_id stored in database on first payment/subscription
10. Subscription record created/updated with lemonsqueezy_subscription_id, status, current_period_end
11. Successful Pro payment updates user tier to "pro" and resets messages_used_count to 0
12. PAYG subscription activation updates user tier to "payg" (no limit enforcement, usage tracked)
13. Webhook signature verification implemented (prevent fraudulent requests)
14. Lemon Squeezy integration tested in test mode with test cards
15. Error handling for failed payments displays user-friendly message
16. Monthly invoice generated by Lemon Squeezy for PAYG users: (interpretations_count × $0.50)
17. Usage tracking idempotent (duplicate reportUsage() calls don't double-charge)

---

## Tasks / Subtasks

- [ ] **Task 1: Install Lemon Squeezy SDK** (AC: 1)
  - [ ] Run: `npm install @lemonsqueezy/lemonsqueezy.js`
  - [ ] Verify package installed in `package.json`
  - [ ] Check current version (3.0+)
  - [ ] Review Lemon Squeezy SDK documentation: https://docs.lemonsqueezy.com/api

- [ ] **Task 2: Create Lemon Squeezy Account and Test/Production Stores** (AC: 1)
  - [ ] Create account at https://lemonsqueezy.com
  - [ ] Create **Test Mode** store: "TowerOfBabel (Test)"
  - [ ] Create **Production Mode** store: "TowerOfBabel"
  - [ ] Generate API keys for both stores:
    - Test mode: `LEMONSQUEEZY_API_KEY_TEST`
    - Production mode: `LEMONSQUEEZY_API_KEY`
  - [ ] Add API keys to `.env.local` and Vercel environment variables
  - [ ] Document store IDs for reference

- [ ] **Task 3: Create Lemon Squeezy Products and Variants** (AC: 2, 3)
  - [ ] Create **Pro Tier Product**:
    - Name: "TowerOfBabel Pro"
    - Price: $10/month
    - Billing cycle: Monthly
    - Description: "100 interpretations per month with automatic reset"
  - [ ] Create **PAYG Tier Product** (Usage-Based):
    - Name: "TowerOfBabel Pay-As-You-Go"
    - Base price: $0/month
    - Usage unit: "interpretation"
    - Usage unit price: $0.50
    - Billing cycle: Monthly (invoiced at month-end)
    - Description: "Pay only for what you use, billed monthly"
  - [ ] Document product IDs and variant IDs for environment variables
  - [ ] Test checkout flow in test mode for both products

- [ ] **Task 4: Add Lemon Squeezy Environment Variables** (AC: 1, 2, 3)
  - [ ] Update `.env.local.example`:
    ```bash
    # Lemon Squeezy Configuration
    LEMONSQUEEZY_API_KEY=your_production_api_key_here
    LEMONSQUEEZY_API_KEY_TEST=your_test_api_key_here
    LEMONSQUEEZY_STORE_ID=your_production_store_id
    LEMONSQUEEZY_STORE_ID_TEST=your_test_store_id
    LEMONSQUEEZY_PRO_VARIANT_ID=your_pro_variant_id
    LEMONSQUEEZY_PAYG_VARIANT_ID=your_payg_variant_id
    LEMONSQUEEZY_WEBHOOK_SECRET=your_webhook_signing_secret
    LEMONSQUEEZY_WEBHOOK_SECRET_TEST=your_test_webhook_signing_secret

    # Lemon Squeezy URLs
    NEXT_PUBLIC_URL=http://localhost:3000  # For local testing
    # Production: https://towerofbabel.com

    # Test mode flag (true/false)
    LEMONSQUEEZY_TEST_MODE=true  # Set to false in production
    ```
  - [ ] Document in README or lib/lemonsqueezy/README.md

- [ ] **Task 5: Create Lemon Squeezy Client** (AC: 1)
  - [ ] Create `/lib/lemonsqueezy/client.ts`:
    ```typescript
    import { lemonSqueezySetup } from '@lemonsqueezy/lemonsqueezy.js';

    /**
     * Initialize Lemon Squeezy API client
     * Automatically uses test or production mode based on environment
     */
    export function configureLemonSqueezy() {
      const isTestMode = process.env.LEMONSQUEEZY_TEST_MODE === 'true';
      const apiKey = isTestMode
        ? process.env.LEMONSQUEEZY_API_KEY_TEST
        : process.env.LEMONSQUEEZY_API_KEY;

      if (!apiKey) {
        throw new Error('Lemon Squeezy API key not configured');
      }

      lemonSqueezySetup({
        apiKey,
        onError: (error) => {
          console.error('Lemon Squeezy Error:', error);
          throw error;
        },
      });
    }

    export function getLemonSqueezyConfig() {
      const isTestMode = process.env.LEMONSQUEEZY_TEST_MODE === 'true';
      return {
        storeId: isTestMode
          ? process.env.LEMONSQUEEZY_STORE_ID_TEST!
          : process.env.LEMONSQUEEZY_STORE_ID!,
        proVariantId: process.env.LEMONSQUEEZY_PRO_VARIANT_ID!,
        paygVariantId: process.env.LEMONSQUEEZY_PAYG_VARIANT_ID!,
        webhookSecret: isTestMode
          ? process.env.LEMONSQUEEZY_WEBHOOK_SECRET_TEST!
          : process.env.LEMONSQUEEZY_WEBHOOK_SECRET!,
        isTestMode,
      };
    }
    ```
  - [ ] Add JSDoc documentation [Source: docs/architecture/16-coding-standards.md#jsdoc-for-public-apis]

- [ ] **Task 6: Create Database Migration for Lemon Squeezy Fields** (AC: 9, 10)
  - [ ] Modify `prisma/schema.prisma`:
    ```prisma
    model User {
      id                        String          @id @default(uuid())
      email                     String          @unique
      tier                      String          @default("trial") // 'trial' | 'payg' | 'pro'
      messages_used_count       Int             @default(0)
      messages_reset_date       DateTime?       // Pro tier reset date
      trial_start_date          DateTime        @default(now())

      // Lemon Squeezy Integration (NEW)
      lemonsqueezy_customer_id  String?         @unique
      subscriptions             Subscription[]  // Relation to subscriptions

      created_at                DateTime        @default(now())
      updated_at                DateTime        @updatedAt
    }

    model Subscription {
      id                              String   @id @default(uuid())
      user_id                         String
      user                            User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

      lemonsqueezy_subscription_id    String   @unique
      lemonsqueezy_order_id           String?
      lemonsqueezy_product_id         String
      lemonsqueezy_variant_id         String

      status                          String   // 'active', 'cancelled', 'expired', 'paused', 'past_due'
      tier                            String   // 'pro' or 'payg'
      renews_at                       DateTime?
      ends_at                         DateTime?
      trial_ends_at                   DateTime?
      billing_anchor                  Int?     // Day of month for billing

      created_at                      DateTime @default(now())
      updated_at                      DateTime @updatedAt

      @@index([user_id])
      @@index([status])
    }

    model LemonSqueezyEvent {
      id                      String   @id @default(uuid())
      lemonsqueezy_event_id   String   @unique  // Idempotency key
      event_type              String   // 'subscription_created', 'subscription_payment_success', etc.
      payload                 Json     // Full webhook payload
      processed_at            DateTime @default(now())

      @@index([lemonsqueezy_event_id])
    }
    ```
  - [ ] Run migration: `npx prisma migrate dev --name add-lemonsqueezy-integration`
  - [ ] Run Prisma generate: `npx prisma generate`
  - [ ] Verify migration applied successfully

- [ ] **Task 7: Create Pro Checkout Endpoint** (AC: 4, 5)
  - [ ] Create `/app/api/checkout/pro/route.ts`:
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { createClient } from '@/lib/auth/supabaseServer';
    import { createCheckout } from '@lemonsqueezy/lemonsqueezy.js';
    import { configureLemonSqueezy, getLemonSqueezyConfig } from '@/lib/lemonsqueezy/client';

    export async function POST(req: NextRequest) {
      // 1. Authentication
      const supabase = createClient();
      const { data: { user }, error } = await supabase.auth.getUser();
      if (error || !user) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      // 2. Configure Lemon Squeezy
      configureLemonSqueezy();
      const config = getLemonSqueezyConfig();

      // 3. Get user email from database
      const userRecord = await prisma.user.findUnique({
        where: { id: user.id },
        select: { email: true, lemonsqueezy_customer_id: true }
      });

      // 4. Create checkout session
      const successUrl = `${process.env.NEXT_PUBLIC_URL}/dashboard?upgrade=success`;
      const cancelUrl = `${process.env.NEXT_PUBLIC_URL}/dashboard?upgrade=cancelled`;

      const checkout = await createCheckout(config.storeId, config.proVariantId, {
        checkoutData: {
          email: userRecord.email,
          custom: {
            user_id: user.id  // Pass user_id to webhook
          }
        },
        checkoutOptions: {
          embed: false,  // Redirect to Lemon Squeezy hosted checkout
          media: true,
          logo: true
        },
        expiresAt: null,  // No expiration
        preview: config.isTestMode,  // Test mode preview
        testMode: config.isTestMode
      });

      if (checkout.error) {
        return NextResponse.json(
          { error: 'Failed to create checkout', details: checkout.error },
          { status: 500 }
        );
      }

      // 5. Return checkout URL
      return NextResponse.json({
        success: true,
        checkoutUrl: checkout.data.data.attributes.url
      });
    }
    ```
  - [ ] Add rate limiting (10 requests/min per user)
  - [ ] Add error logging
  - [ ] Add JSDoc documentation

- [ ] **Task 8: Create PAYG Subscription Endpoint** (AC: 6, 12)
  - [ ] Create `/app/api/subscription/payg/create/route.ts`:
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { createClient } from '@/lib/auth/supabaseServer';
    import { createSubscription } from '@lemonsqueezy/lemonsqueezy.js';
    import { configureLemonSqueezy, getLemonSqueezyConfig } from '@/lib/lemonsqueezy/client';

    export async function POST(req: NextRequest) {
      // 1. Authentication
      const supabase = createClient();
      const { data: { user }, error } = await supabase.auth.getUser();
      if (error || !user) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      // 2. Check if user already has PAYG subscription
      const existingSubscription = await prisma.subscription.findFirst({
        where: {
          user_id: user.id,
          tier: 'payg',
          status: 'active'
        }
      });

      if (existingSubscription) {
        return NextResponse.json(
          { error: 'User already has active PAYG subscription' },
          { status: 400 }
        );
      }

      // 3. Configure Lemon Squeezy
      configureLemonSqueezy();
      const config = getLemonSqueezyConfig();

      // 4. Get user email
      const userRecord = await prisma.user.findUnique({
        where: { id: user.id },
        select: { email: true }
      });

      // 5. Create usage-based subscription (no upfront payment)
      const subscription = await createSubscription(config.storeId, config.paygVariantId, {
        productOptions: {
          enabledVariants: [config.paygVariantId],
          redirectUrl: `${process.env.NEXT_PUBLIC_URL}/dashboard?payg=activated`
        },
        checkoutData: {
          email: userRecord.email,
          custom: {
            user_id: user.id
          }
        },
        preview: config.isTestMode,
        testMode: config.isTestMode
      });

      if (subscription.error) {
        return NextResponse.json(
          { error: 'Failed to create PAYG subscription', details: subscription.error },
          { status: 500 }
        );
      }

      // 6. Update user tier to PAYG immediately (no payment required)
      await prisma.user.update({
        where: { id: user.id },
        data: { tier: 'payg' }
      });

      // 7. Return success
      return NextResponse.json({
        success: true,
        message: 'PAYG subscription activated',
        tier: 'payg'
      });
    }
    ```
  - [ ] Add error handling
  - [ ] Add logging
  - [ ] Add JSDoc documentation

- [ ] **Task 9: Create Webhook Handler Endpoint** (AC: 8, 13)
  - [ ] Create `/app/api/webhooks/lemonsqueezy/route.ts`:
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import crypto from 'crypto';
    import { getLemonSqueezyConfig } from '@/lib/lemonsqueezy/client';
    import { handleSubscriptionCreated } from '@/lib/lemonsqueezy/webhookHandlers/subscriptionCreated';
    import { handleSubscriptionPaymentSuccess } from '@/lib/lemonsqueezy/webhookHandlers/subscriptionPaymentSuccess';
    import { handleSubscriptionCancelled } from '@/lib/lemonsqueezy/webhookHandlers/subscriptionCancelled';
    import { logger } from '@/lib/observability/logger';

    export async function POST(req: NextRequest) {
      // 1. Get raw body for signature verification
      const rawBody = await req.text();
      const signature = req.headers.get('x-signature');

      if (!signature) {
        return NextResponse.json({ error: 'Missing signature' }, { status: 401 });
      }

      // 2. Verify webhook signature
      const config = getLemonSqueezyConfig();
      const hmac = crypto.createHmac('sha256', config.webhookSecret);
      const digest = hmac.update(rawBody).digest('hex');

      if (digest !== signature) {
        logger.warn('Invalid webhook signature', { signature, digest });
        return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
      }

      // 3. Parse webhook payload
      const payload = JSON.parse(rawBody);
      const eventType = payload.meta.event_name;
      const eventId = payload.meta.custom_data?.event_id || payload.data.id;

      // 4. Check for duplicate events (idempotency)
      const existingEvent = await prisma.lemonSqueezyEvent.findUnique({
        where: { lemonsqueezy_event_id: eventId }
      });

      if (existingEvent) {
        logger.info('Duplicate webhook event, skipping', { eventId, eventType });
        return NextResponse.json({ received: true, duplicate: true });
      }

      // 5. Store event for idempotency
      await prisma.lemonSqueezyEvent.create({
        data: {
          lemonsqueezy_event_id: eventId,
          event_type: eventType,
          payload: payload
        }
      });

      // 6. Handle event based on type
      try {
        switch (eventType) {
          case 'subscription_created':
            await handleSubscriptionCreated(payload);
            break;
          case 'subscription_payment_success':
            await handleSubscriptionPaymentSuccess(payload);
            break;
          case 'subscription_cancelled':
          case 'subscription_expired':
            await handleSubscriptionCancelled(payload);
            break;
          case 'usage_updated':
            // Optional: Log usage updates
            logger.info('Usage updated', { payload });
            break;
          default:
            logger.warn('Unhandled webhook event', { eventType });
        }

        return NextResponse.json({ received: true });
      } catch (error) {
        logger.error('Webhook processing error', { error, eventType, eventId });
        return NextResponse.json(
          { error: 'Webhook processing failed' },
          { status: 500 }
        );
      }
    }
    ```
  - [ ] Add comprehensive error handling
  - [ ] Add structured logging for all webhook events
  - [ ] Add JSDoc documentation

- [ ] **Task 10: Create subscription_created Webhook Handler** (AC: 8, 9, 10, 11)
  - [ ] Create `/lib/lemonsqueezy/webhookHandlers/subscriptionCreated.ts`:
    ```typescript
    import { prisma } from '@/lib/db/prisma';
    import { logger } from '@/lib/observability/logger';

    export async function handleSubscriptionCreated(payload: any) {
      const subscription = payload.data.attributes;
      const customData = payload.meta.custom_data;
      const userId = customData.user_id;

      if (!userId) {
        throw new Error('Missing user_id in webhook payload');
      }

      // Determine tier from variant
      const variantId = subscription.variant_id.toString();
      const proVariantId = process.env.LEMONSQUEEZY_PRO_VARIANT_ID;
      const paygVariantId = process.env.LEMONSQUEEZY_PAYG_VARIANT_ID;

      let tier: 'pro' | 'payg';
      if (variantId === proVariantId) {
        tier = 'pro';
      } else if (variantId === paygVariantId) {
        tier = 'payg';
      } else {
        throw new Error(`Unknown variant ID: ${variantId}`);
      }

      // Create subscription record in database
      await prisma.$transaction(async (tx) => {
        // 1. Create subscription
        await tx.subscription.create({
          data: {
            user_id: userId,
            lemonsqueezy_subscription_id: subscription.id.toString(),
            lemonsqueezy_order_id: subscription.order_id?.toString(),
            lemonsqueezy_product_id: subscription.product_id.toString(),
            lemonsqueezy_variant_id: variantId,
            status: subscription.status,
            tier: tier,
            renews_at: subscription.renews_at ? new Date(subscription.renews_at) : null,
            ends_at: subscription.ends_at ? new Date(subscription.ends_at) : null,
            trial_ends_at: subscription.trial_ends_at ? new Date(subscription.trial_ends_at) : null,
            billing_anchor: subscription.billing_anchor
          }
        });

        // 2. Update user tier and customer ID
        await tx.user.update({
          where: { id: userId },
          data: {
            tier: tier,
            lemonsqueezy_customer_id: subscription.customer_id.toString(),
            // Pro tier: Reset usage and set reset date
            ...(tier === 'pro' && {
              messages_used_count: 0,
              messages_reset_date: subscription.renews_at ? new Date(subscription.renews_at) : null
            })
          }
        });
      });

      logger.info('Subscription created', {
        userId,
        tier,
        subscriptionId: subscription.id
      });
    }
    ```
  - [ ] Add error handling
  - [ ] Add JSDoc documentation

- [ ] **Task 11: Create subscription_payment_success Webhook Handler** (AC: 8, 11)
  - [ ] Create `/lib/lemonsqueezy/webhookHandlers/subscriptionPaymentSuccess.ts`:
    ```typescript
    export async function handleSubscriptionPaymentSuccess(payload: any) {
      const subscription = payload.data.attributes;
      const subscriptionId = subscription.id.toString();

      // Find subscription in database
      const dbSubscription = await prisma.subscription.findUnique({
        where: { lemonsqueezy_subscription_id: subscriptionId },
        include: { user: true }
      });

      if (!dbSubscription) {
        logger.warn('Subscription not found for payment success', { subscriptionId });
        return;
      }

      // Pro tier: Reset usage counter on payment success (monthly billing cycle)
      if (dbSubscription.tier === 'pro') {
        await prisma.$transaction(async (tx) => {
          // 1. Reset usage counter
          await tx.user.update({
            where: { id: dbSubscription.user_id },
            data: {
              messages_used_count: 0,
              messages_reset_date: subscription.renews_at ? new Date(subscription.renews_at) : null
            }
          });

          // 2. Update subscription renews_at
          await tx.subscription.update({
            where: { id: dbSubscription.id },
            data: {
              status: subscription.status,
              renews_at: subscription.renews_at ? new Date(subscription.renews_at) : null
            }
          });
        });

        logger.info('Pro subscription renewed, usage reset', {
          userId: dbSubscription.user_id,
          subscriptionId
        });
      }
    }
    ```
  - [ ] Add error handling
  - [ ] Add JSDoc documentation

- [ ] **Task 12: Create subscription_cancelled Webhook Handler** (AC: 8)
  - [ ] Create `/lib/lemonsqueezy/webhookHandlers/subscriptionCancelled.ts`:
    ```typescript
    export async function handleSubscriptionCancelled(payload: any) {
      const subscription = payload.data.attributes;
      const subscriptionId = subscription.id.toString();

      // Find subscription in database
      const dbSubscription = await prisma.subscription.findUnique({
        where: { lemonsqueezy_subscription_id: subscriptionId }
      });

      if (!dbSubscription) {
        logger.warn('Subscription not found for cancellation', { subscriptionId });
        return;
      }

      // Downgrade user to trial tier (blocked until reactivation)
      await prisma.$transaction(async (tx) => {
        // 1. Update subscription status
        await tx.subscription.update({
          where: { id: dbSubscription.id },
          data: {
            status: 'cancelled',
            ends_at: subscription.ends_at ? new Date(subscription.ends_at) : new Date()
          }
        });

        // 2. Downgrade user tier to trial
        await tx.user.update({
          where: { id: dbSubscription.user_id },
          data: {
            tier: 'trial',
            messages_reset_date: null  // Trial doesn't reset
          }
        });
      });

      logger.info('Subscription cancelled, user downgraded to trial', {
        userId: dbSubscription.user_id,
        subscriptionId
      });
    }
    ```
  - [ ] Add error handling
  - [ ] Add JSDoc documentation

- [ ] **Task 13: Implement Usage Reporting to Lemon Squeezy** (AC: 7, 16, 17)
  - [ ] Create `/lib/lemonsqueezy/usageReporting.ts`:
    ```typescript
    import { reportUsage } from '@lemonsqueezy/lemonsqueezy.js';
    import { configureLemonSqueezy } from '@/lib/lemonsqueezy/client';
    import { logger } from '@/lib/observability/logger';

    /**
     * Report interpretation usage to Lemon Squeezy for PAYG billing
     *
     * Idempotent: Uses unique idempotency key (interpretation_id) to prevent double-charging
     *
     * @param subscriptionId - Lemon Squeezy subscription ID
     * @param interpretationId - Unique interpretation ID (idempotency key)
     * @param quantity - Number of interpretations (always 1)
     */
    export async function reportInterpretationUsage(
      subscriptionId: string,
      interpretationId: string,
      quantity: number = 1
    ): Promise<void> {
      try {
        configureLemonSqueezy();

        // Report usage with idempotency key
        const result = await reportUsage(subscriptionId, {
          quantity: quantity,
          idempotencyKey: interpretationId  // Prevents duplicate charging
        });

        if (result.error) {
          throw new Error(`Failed to report usage: ${result.error.message}`);
        }

        logger.info('Usage reported to Lemon Squeezy', {
          subscriptionId,
          interpretationId,
          quantity
        });
      } catch (error) {
        logger.error('Usage reporting failed', {
          subscriptionId,
          interpretationId,
          error
        });
        // Don't throw - allow interpretation to succeed even if usage reporting fails
        // Lemon Squeezy has fallback mechanisms
      }
    }
    ```
  - [ ] Add JSDoc documentation
  - [ ] Add error handling (non-blocking)

- [ ] **Task 14: Integrate Usage Reporting into /api/interpret** (AC: 7, 17)
  - [ ] Modify `/app/api/interpret/route.ts`:
    ```typescript
    import { reportInterpretationUsage } from '@/lib/lemonsqueezy/usageReporting';
    import { prisma } from '@/lib/db/prisma';  // For querying subscription

    export async function POST(req: NextRequest) {
      // ... existing authentication, validation, usage check, cost check, LLM call ...

      // After successful interpretation:
      const result = await llmProvider.interpret(...);

      // Track usage for PAYG users
      if (userRecord.tier === 'payg') {
        const subscription = await prisma.subscription.findFirst({
          where: {
            user_id: user.id,
            tier: 'payg',
            status: 'active'
          }
        });

        if (subscription) {
          // Report usage to Lemon Squeezy (non-blocking)
          await reportInterpretationUsage(
            subscription.lemonsqueezy_subscription_id,
            interpretationRecord.id,  // Unique idempotency key
            1  // One interpretation
          );
        }
      }

      // ... rest of response ...
    }
    ```
  - [ ] Add error handling (don't block interpretation if usage reporting fails)
  - [ ] Add logging for usage reporting success/failure

- [ ] **Task 15: Update UpgradeModal CTA Handlers** (AC: 4, 6)
  - [ ] Modify `/components/features/upgrade/UpgradeModal.tsx`:
    ```typescript
    import { useRouter } from 'next/navigation';
    import { useToast } from '@/components/ui/use-toast';

    export function UpgradeModal({ ...props }: UpgradeModalProps) {
      const router = useRouter();
      const { toast } = useToast();
      const [loading, setLoading] = useState<'pro' | 'payg' | null>(null);

      const handleSubscribeToPro = async () => {
        setLoading('pro');
        try {
          // Call checkout endpoint
          const response = await fetch('/api/checkout/pro', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });

          if (!response.ok) {
            throw new Error('Failed to create checkout session');
          }

          const data = await response.json();

          // Redirect to Lemon Squeezy checkout
          window.location.href = data.checkoutUrl;
        } catch (error) {
          toast({
            title: 'Error',
            description: 'Failed to start subscription. Please try again.',
            variant: 'destructive'
          });
          setLoading(null);
        }
      };

      const handleStartPayAsYouGo = async () => {
        setLoading('payg');
        try {
          // Call PAYG subscription endpoint
          const response = await fetch('/api/subscription/payg/create', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });

          if (!response.ok) {
            throw new Error('Failed to activate Pay-As-You-Go');
          }

          const data = await response.json();

          // Show success message
          toast({
            title: 'Pay-As-You-Go Activated',
            description: 'You can now use interpretations. Billed monthly at $0.50 per use.',
            variant: 'default'
          });

          // Close modal and refresh
          onOpenChange(false);
          router.refresh();
        } catch (error) {
          toast({
            title: 'Error',
            description: 'Failed to activate Pay-As-You-Go. Please try again.',
            variant: 'destructive'
          });
          setLoading(null);
        }
      };

      return (
        <Dialog open={open} onOpenChange={onOpenChange}>
          {/* ... modal content ... */}
          <PricingCard
            tier="pro"
            onCtaClick={handleSubscribeToPro}
            disabled={loading !== null}
            loading={loading === 'pro'}
          />
          <PricingCard
            tier="payg"
            onCtaClick={handleStartPayAsYouGo}
            disabled={loading !== null}
            loading={loading === 'payg'}
          />
        </Dialog>
      );
    }
    ```
  - [ ] Add loading spinners to CTA buttons
  - [ ] Add error handling with user-friendly messages

- [ ] **Task 16: Create Checkout Success/Cancel Pages** (AC: 5)
  - [ ] Create `/app/(dashboard)/checkout/success/page.tsx`:
    ```tsx
    import { redirect } from 'next/navigation';
    import { createClient } from '@/lib/auth/supabaseServer';

    export default async function CheckoutSuccessPage() {
      const supabase = createClient();
      const { data: { user } } = await supabase.auth.getUser();

      if (!user) {
        redirect('/signin');
      }

      return (
        <div className="container max-w-2xl mx-auto px-4 py-16">
          <div className="text-center">
            <h1 className="text-3xl font-bold mb-4">🎉 Subscription Activated!</h1>
            <p className="text-lg text-muted-foreground mb-8">
              Your Pro subscription is now active. You have 100 interpretations per month.
            </p>
            <a
              href="/dashboard"
              className="inline-block px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
            >
              Go to Dashboard
            </a>
          </div>
        </div>
      );
    }
    ```
  - [ ] Create `/app/(dashboard)/checkout/cancelled/page.tsx` with similar structure
  - [ ] Add responsive design
  - [ ] Add session checks to verify user is authenticated

- [ ] **Task 17: Write Unit Tests for Lemon Squeezy Client**
  - [ ] Create `/tests/unit/lib/lemonsqueezy/client.test.ts`
  - [ ] Test: configureLemonSqueezy() sets up API client
  - [ ] Test: getLemonSqueezyConfig() returns correct config for test mode
  - [ ] Test: getLemonSqueezyConfig() returns correct config for production mode
  - [ ] Test: Throws error if API key not configured
  - [ ] Mock environment variables
  - [ ] Use Vitest

- [ ] **Task 18: Write Unit Tests for Webhook Handlers**
  - [ ] Create `/tests/unit/lib/lemonsqueezy/webhookHandlers/subscriptionCreated.test.ts`
  - [ ] Test: Creates subscription and updates user tier to 'pro'
  - [ ] Test: Creates subscription and updates user tier to 'payg'
  - [ ] Test: Resets usage counter for Pro subscriptions
  - [ ] Test: Sets customer_id on user record
  - [ ] Create similar tests for subscriptionPaymentSuccess and subscriptionCancelled handlers
  - [ ] Mock Prisma with different scenarios
  - [ ] Use Vitest

- [ ] **Task 19: Write Integration Tests for Checkout Endpoints**
  - [ ] Create `/tests/integration/api/checkout/pro.test.ts`
  - [ ] Test: Returns 401 for unauthenticated requests
  - [ ] Test: Creates checkout session for authenticated user
  - [ ] Test: Returns checkout URL in response
  - [ ] Test: Checkout URL contains correct variant ID
  - [ ] Mock Lemon Squeezy createCheckout API
  - [ ] Use Vitest + Supertest

- [ ] **Task 20: Write Integration Tests for Webhook Endpoint**
  - [ ] Create `/tests/integration/api/webhooks/lemonsqueezy.test.ts`
  - [ ] Test: Returns 401 for missing signature
  - [ ] Test: Returns 401 for invalid signature
  - [ ] Test: Processes subscription_created event
  - [ ] Test: Processes subscription_payment_success event
  - [ ] Test: Processes subscription_cancelled event
  - [ ] Test: Idempotency - duplicate events skipped
  - [ ] Mock webhook payloads with valid signatures
  - [ ] Use Vitest + Supertest

- [ ] **Task 21: Write Integration Tests for Usage Reporting**
  - [ ] Create `/tests/integration/lemonsqueezy/usageReporting.test.ts`
  - [ ] Test: Reports usage to Lemon Squeezy for PAYG user
  - [ ] Test: Idempotency - same interpretation_id doesn't double-charge
  - [ ] Test: Non-blocking - interpretation succeeds even if reporting fails
  - [ ] Test: No usage reporting for Pro or trial users
  - [ ] Mock Lemon Squeezy reportUsage API
  - [ ] Use Vitest

- [ ] **Task 22: Manual Testing with Lemon Squeezy Test Mode**
  - [ ] Set LEMONSQUEEZY_TEST_MODE=true
  - [ ] Create trial user and click "Subscribe to Pro"
  - [ ] Verify redirects to Lemon Squeezy checkout (test mode)
  - [ ] Complete checkout with test card: 4242 4242 4242 4242
  - [ ] Verify redirects back to success page
  - [ ] Verify webhook fires subscription_created event
  - [ ] Verify user tier updated to 'pro' in database
  - [ ] Verify usage counter reset to 0
  - [ ] Test PAYG activation (no payment required)
  - [ ] Verify user tier updated to 'payg'
  - [ ] Submit interpretation → verify usage reported to Lemon Squeezy
  - [ ] Check Lemon Squeezy dashboard for usage event
  - [ ] **Test payment failure scenario:**
    - [ ] Use declined test card: 4000 0000 0000 0002
    - [ ] Verify user-friendly error message displayed (not technical error)
    - [ ] Verify user NOT charged
    - [ ] Verify user tier NOT updated

- [ ] **Task 23: Manual Testing of Webhook Signature Verification**
  - [ ] Use Lemon Squeezy webhook tester or curl
  - [ ] Send webhook with valid signature → verify 200 response
  - [ ] Send webhook with invalid signature → verify 401 response
  - [ ] Send duplicate webhook (same event_id) → verify duplicate detected
  - [ ] Check database for LemonSqueezyEvent records
  - [ ] Verify idempotency prevents duplicate processing

- [ ] **Task 24: Manual Testing of Subscription Cancellation**
  - [ ] Create Pro user in test mode
  - [ ] Cancel subscription in Lemon Squeezy dashboard
  - [ ] Verify webhook fires subscription_cancelled event
  - [ ] Verify user tier downgraded to 'trial'
  - [ ] Verify user cannot interpret (blocked by trial limit)
  - [ ] Verify subscription status updated to 'cancelled' in database

- [ ] **Task 25: Build and Lint Validation**
  - [ ] Run TypeScript compilation: `npx tsc --noEmit`
  - [ ] Verify no TypeScript errors
  - [ ] Run ESLint: `npm run lint`
  - [ ] Verify no ESLint errors (warnings acceptable)
  - [ ] Run unit tests: `npm test tests/unit`
  - [ ] Run integration tests: `npm test tests/integration`
  - [ ] Verify all tests pass
  - [ ] Check bundle size impact (< 300KB total goal)

- [ ] **Task 26: Commit Changes**
  - [ ] Stage all changes: `git add .`
  - [ ] Commit with conventional commit message: `feat(payments): integrate Lemon Squeezy for subscriptions and metered billing (Story 3.4)` [Source: docs/architecture/16-coding-standards.md#conventional-commits]
  - [ ] Push to GitHub: `git push origin main`
  - [ ] Verify CI pipeline passes

- [ ] **Task 27: Write Unit Tests for PAYG Subscription Endpoint**
  - [ ] Create `/tests/unit/api/subscription/payg/create.test.ts`
  - [ ] Test: Returns 401 for unauthenticated requests
  - [ ] Test: Returns 400 if user already has active PAYG subscription
  - [ ] Test: Creates subscription in Lemon Squeezy
  - [ ] Test: Updates user tier to 'payg' immediately
  - [ ] Test: Handles Lemon Squeezy API errors gracefully
  - [ ] Mock Lemon Squeezy createSubscription API
  - [ ] Mock Prisma for subscription checks
  - [ ] Use Vitest + Supertest

- [ ] **Task 28: Write Integration Tests for Database Transactions**
  - [ ] Create `/tests/integration/lemonsqueezy/database-transactions.test.ts`
  - [ ] Test: subscription_created webhook creates Subscription AND updates User atomically
  - [ ] Test: subscription_payment_success resets usage AND updates subscription atomically
  - [ ] Test: subscription_cancelled updates Subscription AND downgrades User atomically
  - [ ] Test: Rollback on failure (e.g., invalid user_id) - no partial updates
  - [ ] Test: Concurrent subscription_created events don't create duplicates (race condition)
  - [ ] Use Vitest with real Prisma instance (test database)
  - [ ] Critical: Verify $transaction ensures atomicity

- [ ] **Task 29: Write Security Tests for Webhook Endpoint**
  - [ ] Create `/tests/integration/api/webhooks/lemonsqueezy-security.test.ts`
  - [ ] Test: Rejects webhook with missing x-signature header
  - [ ] Test: Rejects webhook with wrong signature (tampered payload)
  - [ ] Test: Accepts webhook with valid signature
  - [ ] Test: Rejects webhook with expired signature (if applicable)
  - [ ] Test: Rate limiting on webhook endpoint (if implemented)
  - [ ] Test: Large payload handling (DoS protection)
  - [ ] Use Vitest with crafted webhook payloads
  - [ ] Generate valid/invalid HMAC signatures for testing

- [ ] **Task 30: Write Integration Tests for UpgradeModal Payment Flow**
  - [ ] Create `/tests/integration/components/UpgradeModal-payment.test.tsx`
  - [ ] Test: "Subscribe to Pro" button calls /api/checkout/pro
  - [ ] Test: Successful checkout redirects to Lemon Squeezy URL
  - [ ] Test: Failed checkout displays error toast
  - [ ] Test: "Start Pay-As-You-Go" button calls /api/subscription/payg/create
  - [ ] Test: Successful PAYG activation shows success toast and refreshes
  - [ ] Test: Failed PAYG activation displays error toast
  - [ ] Test: Loading state prevents double-clicks
  - [ ] Mock fetch API and router
  - [ ] Use Vitest + React Testing Library

- [ ] **Task 31: Write Unit Tests for Usage Reporting Idempotency**
  - [ ] Create `/tests/unit/lib/lemonsqueezy/usageReporting-idempotency.test.ts`
  - [ ] Test: Same interpretationId sent twice → reportUsage called once
  - [ ] Test: Different interpretationIds → both reported
  - [ ] Test: reportUsage failure → doesn't throw (non-blocking)
  - [ ] Test: reportUsage failure → logs error
  - [ ] Test: Lemon Squeezy API returns 409 Conflict (duplicate) → handled gracefully
  - [ ] Mock Lemon Squeezy reportUsage API with idempotency behavior
  - [ ] Use Vitest

- [ ] **Task 32: Write Integration Tests for Payment Failure Scenarios**
  - [ ] Create `/tests/integration/lemonsqueezy/payment-failures.test.ts`
  - [ ] Test: Declined card → subscription NOT created, user NOT upgraded
  - [ ] Test: Lemon Squeezy API timeout → user sees retry message
  - [ ] Test: Lemon Squeezy API 500 error → graceful error handling
  - [ ] Test: Webhook delivery failure → eventual consistency via Lemon Squeezy retries
  - [ ] Test: Payment succeeded but webhook failed → manual reconciliation possible
  - [ ] Mock Lemon Squeezy API errors (400, 500, timeout)
  - [ ] Use Vitest

- [ ] **Task 33: Write Unit Tests for Environment Variable Validation**
  - [ ] Create `/tests/unit/lib/lemonsqueezy/config-validation.test.ts`
  - [ ] Test: configureLemonSqueezy() throws error if API key missing
  - [ ] Test: getLemonSqueezyConfig() throws error if store ID missing
  - [ ] Test: getLemonSqueezyConfig() throws error if variant IDs missing
  - [ ] Test: getLemonSqueezyConfig() throws error if webhook secret missing
  - [ ] Test: Test mode flag switches between test/production configs
  - [ ] Mock process.env with missing/invalid values
  - [ ] Use Vitest

- [ ] **Task 34: Write Integration Tests for Concurrent Payment Attempts**
  - [ ] Create `/tests/integration/lemonsqueezy/concurrent-payments.test.ts`
  - [ ] Test: Multiple simultaneous Pro checkout requests from same user → only one succeeds
  - [ ] Test: Concurrent PAYG activation requests → idempotent, no duplicate subscriptions
  - [ ] Test: User clicks "Subscribe" button rapidly → rate limiting prevents duplicates
  - [ ] Test: Concurrent webhook processing for same subscription → idempotency works
  - [ ] Test: Race condition: subscription_created webhook arrives before checkout completes
  - [ ] Mock concurrent requests with Promise.all()
  - [ ] Use Vitest with real database (test for race conditions)

- [ ] **Task 35: Write Integration Tests for Subscription Lifecycle**
  - [ ] Create `/tests/integration/lemonsqueezy/subscription-lifecycle.test.ts`
  - [ ] Test: Complete Pro subscription lifecycle (create → renew → cancel → reactivate)
  - [ ] Test: Trial → Pro upgrade flow
  - [ ] Test: Trial → PAYG upgrade flow
  - [ ] Test: Pro → PAYG downgrade (if allowed)
  - [ ] Test: Subscription cancelled mid-cycle → user retains access until period end
  - [ ] Test: Subscription expired → user downgraded to trial immediately
  - [ ] Test: Subscription paused → appropriate status updates
  - [ ] Mock Lemon Squeezy webhook sequence for full lifecycle
  - [ ] Use Vitest

- [ ] **Task 36: Write Unit Tests for Webhook Handler Error Recovery**
  - [ ] Create `/tests/unit/lib/lemonsqueezy/webhookHandlers/error-recovery.test.ts`
  - [ ] Test: Database connection failure during webhook → retries successfully
  - [ ] Test: Transaction rollback on Prisma error → no partial data updates
  - [ ] Test: Invalid payload format → logs error, returns 400, doesn't crash
  - [ ] Test: Missing user_id in webhook → logs error, returns 400
  - [ ] Test: User not found in database → logs error, returns 404
  - [ ] Test: Subscription already exists → handles gracefully (idempotency)
  - [ ] Mock Prisma errors (connection, transaction, constraint violations)
  - [ ] Use Vitest

- [ ] **Task 37: Write Integration Tests for PAYG Usage Aggregation**
  - [ ] Create `/tests/integration/lemonsqueezy/payg-usage-aggregation.test.ts`
  - [ ] Test: Multiple interpretations in same billing period → all usage reported
  - [ ] Test: Usage reporting across month boundary → correct billing period
  - [ ] Test: Zero usage month → no charge, subscription remains active
  - [ ] Test: High usage month (100+ interpretations) → all counted correctly
  - [ ] Test: Usage reporting failure + retry → eventually consistent
  - [ ] Test: Lemon Squeezy usage API rate limiting → backoff and retry
  - [ ] Mock Lemon Squeezy usage aggregation API
  - [ ] Use Vitest

- [ ] **Task 38: Write Integration Tests for Data Consistency Checks**
  - [ ] Create `/tests/integration/lemonsqueezy/data-consistency.test.ts`
  - [ ] Test: User.tier always matches active Subscription.tier
  - [ ] Test: Cancelled subscription → user downgraded, no orphaned subscription
  - [ ] Test: Deleted user → cascades to Subscription deletion
  - [ ] Test: Multiple active subscriptions prevented (business rule)
  - [ ] Test: messages_reset_date matches subscription.renews_at for Pro users
  - [ ] Test: lemonsqueezy_customer_id unique constraint enforced
  - [ ] Test: Subscription status transitions are valid (active → cancelled, not cancelled → active without webhook)
  - [ ] Use Vitest with real database
  - [ ] Query database after operations to verify consistency

- [ ] **Task 39: Write Unit Tests for Checkout Endpoint Edge Cases**
  - [ ] Create `/tests/unit/api/checkout/pro-edge-cases.test.ts`
  - [ ] Test: User already has Pro subscription → returns error or allows upgrade
  - [ ] Test: User has PAYG, upgrades to Pro → PAYG cancelled, Pro activated
  - [ ] Test: Invalid email format → validation error
  - [ ] Test: Lemon Squeezy API rate limit → retry with exponential backoff
  - [ ] Test: Checkout session creation timeout → returns 504 Gateway Timeout
  - [ ] Test: Network error to Lemon Squeezy → user-friendly error message
  - [ ] Test: Test mode vs production mode checkout URLs different
  - [ ] Mock Lemon Squeezy createCheckout with various error responses
  - [ ] Use Vitest + Supertest

- [ ] **Task 40: Write Integration Tests for Webhook Retry Logic**
  - [ ] Create `/tests/integration/api/webhooks/lemonsqueezy-retry.test.ts`
  - [ ] Test: Webhook fails first time → Lemon Squeezy retries → succeeds on retry
  - [ ] Test: Webhook idempotency prevents duplicate processing on retry
  - [ ] Test: Webhook exponential backoff (Lemon Squeezy behavior) → eventual success
  - [ ] Test: Webhook permanently fails after max retries → manual reconciliation required
  - [ ] Test: Webhook arrives out of order (payment_success before created) → handles gracefully
  - [ ] Simulate Lemon Squeezy retry behavior with multiple requests
  - [ ] Use Vitest + Supertest

- [ ] **Task 41: Write End-to-End Tests for Complete Payment Flows**
  - [ ] Create `/tests/e2e/payment-flows.test.ts`
  - [ ] Test: E2E Pro subscription (UI click → API → Lemon Squeezy → webhook → database → UI update)
  - [ ] Test: E2E PAYG activation (UI click → API → database → UI update)
  - [ ] Test: E2E interpretation with PAYG usage reporting (interpret → usage report → Lemon Squeezy)
  - [ ] Test: E2E subscription cancellation (Lemon Squeezy → webhook → database → UI update)
  - [ ] Test: E2E Pro renewal (time passes → webhook → usage reset → UI update)
  - [ ] Use Playwright or Cypress for browser automation
  - [ ] Mock Lemon Squeezy checkout (redirect to mock page, trigger webhook manually)
  - [ ] Verify full flow from user action to data persistence to UI feedback

- [ ] **Task 42: Write Performance Tests for Payment Endpoints**
  - [ ] Create `/tests/performance/payment-endpoints.test.ts`
  - [ ] Test: /api/checkout/pro response time < 500ms (p95)
  - [ ] Test: /api/subscription/payg/create response time < 300ms (p95)
  - [ ] Test: /api/webhooks/lemonsqueezy processing time < 1000ms (p95)
  - [ ] Test: Database transaction time for subscription creation < 200ms
  - [ ] Test: 100 concurrent checkout requests → all succeed or fail gracefully
  - [ ] Test: Webhook endpoint handles 50 requests/second without degradation
  - [ ] Use k6 or Artillery for load testing
  - [ ] Monitor database connection pool under load

- [ ] **Task 43: Write Integration Tests for Billing Period Edge Cases**
  - [ ] Create `/tests/integration/lemonsqueezy/billing-period-edge-cases.test.ts`
  - [ ] Test: Pro subscription created on Jan 31 → renews on Feb 28 (short month)
  - [ ] Test: Usage reset happens exactly at billing_anchor day
  - [ ] Test: Subscription created mid-month → prorated charge (if applicable)
  - [ ] Test: Timezone handling for billing periods (UTC vs user timezone)
  - [ ] Test: Leap year billing cycle (Feb 29)
  - [ ] Test: Year-end billing cycle (Dec 31 → Jan 1)
  - [ ] Test: messages_reset_date updates correctly on each renewal
  - [ ] Mock webhook payloads with various billing_anchor dates
  - [ ] Use Vitest

- [ ] **Task 44: Write Unit Tests for Usage Reporting Error Scenarios**
  - [ ] Create `/tests/unit/lib/lemonsqueezy/usageReporting-errors.test.ts`
  - [ ] Test: Lemon Squeezy API returns 400 Bad Request → logs error, doesn't throw
  - [ ] Test: Lemon Squeezy API returns 500 Server Error → logs error, doesn't throw
  - [ ] Test: Network timeout → logs error, doesn't throw
  - [ ] Test: Invalid subscription ID → logs error, doesn't throw
  - [ ] Test: Rate limit error (429) → implements backoff, retries
  - [ ] Test: Usage reporting for cancelled subscription → fails gracefully
  - [ ] Verify interpretation succeeds despite reporting failures (non-blocking)
  - [ ] Use Vitest

- [ ] **Task 45: Write Integration Tests for Subscription Status Transitions**
  - [ ] Create `/tests/integration/lemonsqueezy/subscription-status-transitions.test.ts`
  - [ ] Test: active → cancelled (user cancels)
  - [ ] Test: active → expired (subscription ends without renewal)
  - [ ] Test: active → past_due (payment fails)
  - [ ] Test: past_due → active (payment succeeds after retry)
  - [ ] Test: past_due → cancelled (payment fails repeatedly)
  - [ ] Test: cancelled → active (user reactivates)
  - [ ] Test: Invalid transitions prevented (e.g., expired → active without webhook)
  - [ ] Test: Subscription.status always synced with Lemon Squeezy
  - [ ] Mock webhook sequences for each transition
  - [ ] Use Vitest

- [ ] **Task 46: Write Security Tests for Payment Endpoint Authorization**
  - [ ] Create `/tests/integration/api/checkout/security.test.ts`
  - [ ] Test: Unauthenticated user cannot create checkout session
  - [ ] Test: User A cannot create checkout for User B (authorization check)
  - [ ] Test: Expired session token → 401 Unauthorized
  - [ ] Test: Invalid API key for Lemon Squeezy → error handled securely (no API key leak)
  - [ ] Test: SQL injection attempts in user input → sanitized
  - [ ] Test: XSS attempts in custom_data → sanitized
  - [ ] Test: Rate limiting prevents checkout abuse (10 req/min enforced)
  - [ ] Use Vitest + Supertest with malicious payloads

- [ ] **Task 47: Write Integration Tests for Customer ID Management**
  - [ ] Create `/tests/integration/lemonsqueezy/customer-id-management.test.ts`
  - [ ] Test: First subscription → lemonsqueezy_customer_id set
  - [ ] Test: Second subscription (same user) → customer_id unchanged
  - [ ] Test: Multiple users → unique customer IDs enforced
  - [ ] Test: Customer ID used for subsequent checkouts (returning customer)
  - [ ] Test: Orphaned customer ID (no active subscription) → handled correctly
  - [ ] Test: Customer ID change not allowed after initial set
  - [ ] Use Vitest with real database
  - [ ] Verify unique constraint on lemonsqueezy_customer_id

- [ ] **Task 48: Write Unit Tests for Webhook Payload Validation**
  - [ ] Create `/tests/unit/api/webhooks/lemonsqueezy-payload-validation.test.ts`
  - [ ] Test: Valid subscription_created payload → parsed correctly
  - [ ] Test: Missing required fields → validation error
  - [ ] Test: Invalid field types (string instead of number) → validation error
  - [ ] Test: Extra unexpected fields → ignored gracefully
  - [ ] Test: Malformed JSON → returns 400 Bad Request
  - [ ] Test: Empty payload → returns 400 Bad Request
  - [ ] Test: Extremely large payload (10MB+) → rejected (DoS protection)
  - [ ] Use Vitest with schema validation (Zod or similar)

- [ ] **Task 49: Write Integration Tests for Subscription Reactivation**
  - [ ] Create `/tests/integration/lemonsqueezy/subscription-reactivation.test.ts`
  - [ ] Test: User cancels Pro → downgrades to trial → reactivates Pro → tier restored
  - [ ] Test: Reactivation creates new subscription record (not updates old cancelled one)
  - [ ] Test: Reactivation webhook → user tier updated immediately
  - [ ] Test: Reactivation mid-cycle → prorated charge calculated correctly
  - [ ] Test: Reactivation of expired subscription → usage reset to 0
  - [ ] Test: Multiple reactivations tracked correctly in database
  - [ ] Mock Lemon Squeezy reactivation webhook
  - [ ] Use Vitest

- [ ] **Task 50: Write Manual Tests for Production Readiness**
  - [ ] Create production checklist in `/docs/testing/payment-production-checklist.md`
  - [ ] Test: Verify LEMONSQUEEZY_TEST_MODE=false in production
  - [ ] Test: Verify production API keys configured in Vercel
  - [ ] Test: Verify webhook endpoint accessible from internet (not localhost)
  - [ ] Test: Verify webhook secret matches Lemon Squeezy configuration
  - [ ] Test: Test real credit card (small amount) in production → refund immediately
  - [ ] Test: Verify SSL certificate valid for webhook endpoint
  - [ ] Test: Verify webhook logs captured in production logging system
  - [ ] Test: Verify alert system triggers on payment failures
  - [ ] Test: Verify database backups configured for subscription data
  - [ ] Test: Verify PCI compliance checklist completed
  - [ ] Document rollback plan for production issues

---

## Dev Notes

### Story Context and Integration

**This story integrates Lemon Squeezy payment processing to enable Pro subscriptions and Pay-As-You-Go metered billing.**

**Integration Flow:**
- Story 3.1: Backend usage limit enforcement (DONE)
- Story 3.2: Usage indicator + notifications (APPROVED)
- Story 3.3: Upgrade modal with pricing tiers (READY FOR IMPLEMENTATION)
- **Story 3.4 (THIS STORY):** Lemon Squeezy payment integration
- Story 3.5: Billing portal and subscription management

**Key Insights from Story 3.3:**
- UpgradeModal has placeholder CTA handlers ready for Lemon Squeezy integration
- "Subscribe to Pro" button should redirect to Lemon Squeezy Checkout
- "Start Pay-As-You-Go" button should activate PAYG subscription (no upfront payment)
- upgradeModalStore tracks trigger source for analytics

**What Story 3.4 Adds:**
- ✨ **NEW:** Lemon Squeezy SDK integration (@lemonsqueezy/lemonsqueezy.js)
- ✨ **NEW:** Pro tier checkout session creation
- ✨ **NEW:** PAYG tier usage-based subscription creation (no upfront payment)
- ✨ **NEW:** Webhook endpoint for subscription events (subscription_created, subscription_payment_success, subscription_cancelled)
- ✨ **NEW:** Idempotent webhook processing (LemonSqueezyEvent table)
- ✨ **NEW:** Usage reporting to Lemon Squeezy for PAYG users ($0.50 per interpretation)
- ✨ **NEW:** Database tables: Subscription, LemonSqueezyEvent
- ✨ **NEW:** Checkout success/cancel pages

**What Story 3.5 Will Add:**
- Billing portal link for users to manage subscriptions
- View billing history and invoices
- Update payment method
- Cancel subscription via Customer Portal

---

### CRITICAL Architectural Patterns

#### Idempotent Webhook Processing

**Pattern:** Prevent duplicate webhook processing using event_id as idempotency key.

```typescript
// /app/api/webhooks/lemonsqueezy/route.ts
export async function POST(req: NextRequest) {
  const payload = JSON.parse(rawBody);
  const eventId = payload.meta.custom_data?.event_id || payload.data.id;

  // Check for duplicate events
  const existingEvent = await prisma.lemonSqueezyEvent.findUnique({
    where: { lemonsqueezy_event_id: eventId }
  });

  if (existingEvent) {
    logger.info('Duplicate webhook event, skipping', { eventId });
    return NextResponse.json({ received: true, duplicate: true });
  }

  // Store event before processing
  await prisma.lemonSqueezyEvent.create({
    data: {
      lemonsqueezy_event_id: eventId,
      event_type: eventType,
      payload: payload
    }
  });

  // Process event
  await handleWebhookEvent(payload);
}
```

**Why This Pattern:**
- Webhooks may be delivered multiple times (network retries, Lemon Squeezy retries)
- Duplicate processing could double-charge users or cause data corruption
- LemonSqueezyEvent table acts as idempotency log
- Critical for subscription_created (prevents duplicate subscription records)
- Critical for subscription_payment_success (prevents double usage resets)

[Source: docs/architecture/6-components.md#component-5-lemon-squeezy-integration-service]

---

#### Webhook Signature Verification

**Pattern:** Verify HMAC signature to prevent fraudulent webhook requests.

```typescript
import crypto from 'crypto';

export async function POST(req: NextRequest) {
  // 1. Get raw body (required for signature verification)
  const rawBody = await req.text();
  const signature = req.headers.get('x-signature');

  if (!signature) {
    return NextResponse.json({ error: 'Missing signature' }, { status: 401 });
  }

  // 2. Compute HMAC signature
  const config = getLemonSqueezyConfig();
  const hmac = crypto.createHmac('sha256', config.webhookSecret);
  const digest = hmac.update(rawBody).digest('hex');

  // 3. Compare signatures
  if (digest !== signature) {
    logger.warn('Invalid webhook signature', { signature, digest });
    return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
  }

  // 4. Safe to process webhook
  const payload = JSON.parse(rawBody);
  // ...
}
```

**Why This Pattern:**
- Prevents malicious actors from faking webhooks
- Ensures webhooks actually come from Lemon Squeezy
- Critical for financial operations (subscription creation, cancellation)
- Required by PCI compliance (NFR10)

**Implementation Note:**
- Use raw body (text) for signature verification, NOT parsed JSON
- Lemon Squeezy uses SHA-256 HMAC with webhook secret
- Signature in `x-signature` header

[Source: docs/architecture/6-components.md#component-5-lemon-squeezy-integration-service]

---

### Lemon Squeezy Configuration

**Test Mode vs Production Mode:**

```typescript
// /lib/lemonsqueezy/client.ts
export function configureLemonSqueezy() {
  const isTestMode = process.env.LEMONSQUEEZY_TEST_MODE === 'true';
  const apiKey = isTestMode
    ? process.env.LEMONSQUEEZY_API_KEY_TEST
    : process.env.LEMONSQUEEZY_API_KEY;

  lemonSqueezySetup({
    apiKey,
    onError: (error) => {
      console.error('Lemon Squeezy Error:', error);
      throw error;
    },
  });
}
```

**Environment Variables:**
```bash
# Test Mode Configuration
LEMONSQUEEZY_TEST_MODE=true
LEMONSQUEEZY_API_KEY_TEST=your_test_api_key
LEMONSQUEEZY_STORE_ID_TEST=your_test_store_id
LEMONSQUEEZY_WEBHOOK_SECRET_TEST=your_test_webhook_secret

# Production Mode Configuration
LEMONSQUEEZY_TEST_MODE=false  # Set in production
LEMONSQUEEZY_API_KEY=your_production_api_key
LEMONSQUEEZY_STORE_ID=your_production_store_id
LEMONSQUEEZY_WEBHOOK_SECRET=your_production_webhook_secret

# Product Configuration
LEMONSQUEEZY_PRO_VARIANT_ID=12345  # Pro tier variant
LEMONSQUEEZY_PAYG_VARIANT_ID=67890  # PAYG tier variant
```

**Why Test Mode:**
- Develop and test without real charges
- Use test cards: 4242 4242 4242 4242
- Separate webhook endpoints for test/production
- Easy to reset test data

**Setting Up Test Mode:**
1. Create separate test store in Lemon Squeezy
2. Create test products and variants
3. Generate test API key
4. Set LEMONSQUEEZY_TEST_MODE=true in .env.local
5. Test checkout flow with test card
6. Verify webhooks fire in test mode

[Source: docs/architecture/3-tech-stack.md]

---

### Pro Tier Checkout Flow

**User Journey:**
1. User clicks "Subscribe to Pro" in UpgradeModal
2. Frontend calls `/api/checkout/pro` (POST)
3. Backend creates Lemon Squeezy checkout session
4. Backend returns `checkoutUrl`
5. Frontend redirects to Lemon Squeezy hosted checkout page
6. User enters payment details (or uses saved card)
7. Lemon Squeezy processes payment
8. Lemon Squeezy sends `subscription_created` webhook to `/api/webhooks/lemonsqueezy`
9. Webhook handler creates subscription record, updates user tier to 'pro', resets usage
10. Lemon Squeezy redirects back to `/checkout/success`
11. User sees success message, redirects to dashboard

**Checkout Session Creation:**

```typescript
// /app/api/checkout/pro/route.ts
const checkout = await createCheckout(config.storeId, config.proVariantId, {
  checkoutData: {
    email: userRecord.email,
    custom: {
      user_id: user.id  // Pass user_id to webhook
    }
  },
  checkoutOptions: {
    embed: false,  // Redirect to hosted checkout (not embedded)
    media: true,   // Show product media
    logo: true     // Show TowerOfBabel logo
  },
  expiresAt: null,  // No expiration
  preview: config.isTestMode,  // Preview mode for testing
  testMode: config.isTestMode
});

// Returns: { data: { attributes: { url: 'https://checkout.lemonsqueezy.com/...' } } }
```

**Success/Cancel URLs:**
```typescript
// Configured in Lemon Squeezy product settings or checkout options
const successUrl = `${process.env.NEXT_PUBLIC_URL}/checkout/success`;
const cancelUrl = `${process.env.NEXT_PUBLIC_URL}/checkout/cancelled`;
```

**Why Hosted Checkout:**
- PCI compliant (Lemon Squeezy handles card details)
- No credit card fields in TowerOfBabel UI
- Supports multiple payment methods (cards, Apple Pay, Google Pay)
- Lemon Squeezy handles 3D Secure, fraud detection, VAT collection

[Source: Epic 3 AC 4, 5]

---

### PAYG Tier Activation Flow

**User Journey:**
1. User clicks "Start Pay-As-You-Go" in UpgradeModal
2. Frontend calls `/api/subscription/payg/create` (POST)
3. Backend creates Lemon Squeezy usage-based subscription (no upfront payment)
4. Backend updates user tier to 'payg' immediately
5. Frontend shows success toast, refreshes page
6. User can now interpret (usage tracked, billed monthly)

**PAYG Subscription Creation:**

```typescript
// /app/api/subscription/payg/create/route.ts
const subscription = await createSubscription(config.storeId, config.paygVariantId, {
  productOptions: {
    enabledVariants: [config.paygVariantId],
    redirectUrl: `${process.env.NEXT_PUBLIC_URL}/dashboard?payg=activated`
  },
  checkoutData: {
    email: userRecord.email,
    custom: {
      user_id: user.id
    }
  },
  preview: config.isTestMode,
  testMode: config.isTestMode
});

// No payment required upfront - user billed at month-end
```

**Why No Upfront Payment:**
- PAYG is usage-based ($0/month base + $0.50 per interpretation)
- User only pays for what they use
- Billed monthly at end of billing cycle
- Lowers barrier to entry vs Pro ($10 upfront)

**Usage Reporting:**
```typescript
// After each interpretation for PAYG users:
await reportInterpretationUsage(
  subscription.lemonsqueezy_subscription_id,
  interpretationRecord.id,  // Idempotency key
  1  // Quantity
);
```

**Monthly Billing:**
- Lemon Squeezy aggregates usage events
- Generates invoice at month-end: (interpretation_count × $0.50)
- Sends `subscription_payment_success` webhook after payment
- User can view invoice in Billing Portal (Story 3.5)

[Source: Epic 3 AC 6, 7, 16, 17]

---

### Webhook Event Handling

**subscription_created (AC: 8, 9, 10, 11)**

Triggered when user completes checkout (Pro) or activates PAYG.

```typescript
// Payload structure
{
  meta: {
    event_name: 'subscription_created',
    custom_data: {
      user_id: 'user-uuid'  // Passed from checkout
    }
  },
  data: {
    id: '12345',
    attributes: {
      customer_id: '67890',
      product_id: '123',
      variant_id: '456',  // Pro or PAYG variant
      status: 'active',
      renews_at: '2025-11-24T00:00:00Z',
      // ...
    }
  }
}
```

**Handler Actions:**
1. Create Subscription record in database
2. Update user.tier to 'pro' or 'payg'
3. Update user.lemonsqueezy_customer_id (first time only)
4. If Pro: Reset messages_used_count to 0, set messages_reset_date
5. If PAYG: No usage reset (unlimited, billed per use)

**subscription_payment_success (AC: 8, 11)**

Triggered on recurring Pro payments (monthly billing cycle).

```typescript
// Handler Actions (Pro tier only):
1. Reset messages_used_count to 0
2. Update messages_reset_date to next billing date
3. Update subscription.renews_at
```

**subscription_cancelled (AC: 8)**

Triggered when user cancels subscription or payment fails repeatedly.

```typescript
// Handler Actions:
1. Update subscription.status to 'cancelled'
2. Downgrade user.tier to 'trial'
3. Set subscription.ends_at
// User blocked by trial limits (10 messages, 14 days)
```

**usage_updated (AC: 8)**

Triggered when usage is reported for PAYG users (optional logging).

```typescript
// Handler Actions (optional):
1. Log usage event for audit trail
2. No database updates needed (Lemon Squeezy tracks usage)
```

[Source: Epic 3 AC 8]

---

### Usage Reporting Idempotency (AC: 17)

**Problem:** Duplicate usage reports could double-charge PAYG users.

**Solution:** Use interpretation_id as idempotency key.

```typescript
// /lib/lemonsqueezy/usageReporting.ts
export async function reportInterpretationUsage(
  subscriptionId: string,
  interpretationId: string,  // Unique ID from database
  quantity: number = 1
): Promise<void> {
  const result = await reportUsage(subscriptionId, {
    quantity: quantity,
    idempotencyKey: interpretationId  // Prevents duplicate charging
  });

  // Lemon Squeezy deduplicates by idempotencyKey
  // Same interpretationId sent twice = charged once
}
```

**Why This Works:**
- Each interpretation has unique ID in database
- Same ID used for both interpretation record AND usage reporting
- Lemon Squeezy API deduplicates based on idempotencyKey
- Safe to retry usage reporting on failure (won't double-charge)

**Error Handling:**
```typescript
try {
  await reportInterpretationUsage(...);
} catch (error) {
  logger.error('Usage reporting failed', { error });
  // Don't throw - allow interpretation to succeed
  // Lemon Squeezy has fallback mechanisms and reconciliation
}
```

**Non-Blocking:**
- Usage reporting failure doesn't block interpretation
- User gets interpretation result even if reporting fails
- Lemon Squeezy can reconcile missing usage events

[Source: Epic 3 AC 17]

---

### Database Schema Changes

**New Tables:**

**1. Subscription**
```prisma
model Subscription {
  id                              String   @id @default(uuid())
  user_id                         String
  user                            User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  lemonsqueezy_subscription_id    String   @unique
  lemonsqueezy_order_id           String?
  lemonsqueezy_product_id         String
  lemonsqueezy_variant_id         String

  status                          String   // 'active', 'cancelled', 'expired', 'paused', 'past_due'
  tier                            String   // 'pro' or 'payg'
  renews_at                       DateTime?
  ends_at                         DateTime?
  trial_ends_at                   DateTime?
  billing_anchor                  Int?     // Day of month for billing

  created_at                      DateTime @default(now())
  updated_at                      DateTime @updatedAt

  @@index([user_id])
  @@index([status])
}
```

**2. LemonSqueezyEvent (Idempotency Log)**
```prisma
model LemonSqueezyEvent {
  id                      String   @id @default(uuid())
  lemonsqueezy_event_id   String   @unique  // Idempotency key
  event_type              String   // 'subscription_created', etc.
  payload                 Json     // Full webhook payload
  processed_at            DateTime @default(now())

  @@index([lemonsqueezy_event_id])
}
```

**Modified Tables:**

**User**
```prisma
model User {
  id                        String          @id @default(uuid())
  email                     String          @unique
  tier                      String          @default("trial")
  messages_used_count       Int             @default(0)
  messages_reset_date       DateTime?

  // NEW FIELDS
  lemonsqueezy_customer_id  String?         @unique
  subscriptions             Subscription[]  // Relation

  // ... existing fields
}
```

**Why These Changes:**
- Subscription table: Tracks Lemon Squeezy subscription data
- LemonSqueezyEvent table: Prevents duplicate webhook processing
- lemonsqueezy_customer_id: Links user to Lemon Squeezy customer record
- Cascade delete: Deleting user deletes subscriptions (GDPR compliance)

[Source: docs/architecture/4-data-models.md, docs/architecture/9-database-schema.md]

---

### File Locations and Project Structure

**Files to Create:**
```
/lib/lemonsqueezy/
  ├── client.ts                              # CREATE: Lemon Squeezy SDK setup
  ├── usageReporting.ts                      # CREATE: Usage reporting for PAYG
  └── webhookHandlers/
      ├── subscriptionCreated.ts             # CREATE: subscription_created handler
      ├── subscriptionPaymentSuccess.ts      # CREATE: subscription_payment_success handler
      └── subscriptionCancelled.ts           # CREATE: subscription_cancelled handler

/app/api/checkout/pro/
  └── route.ts                               # CREATE: Pro checkout endpoint

/app/api/subscription/payg/create/
  └── route.ts                               # CREATE: PAYG subscription endpoint

/app/api/webhooks/lemonsqueezy/
  └── route.ts                               # CREATE: Webhook handler endpoint

/app/(dashboard)/checkout/
  ├── success/page.tsx                       # CREATE: Checkout success page
  └── cancelled/page.tsx                     # CREATE: Checkout cancelled page

/prisma/
  └── migrations/                            # CREATE: add-lemonsqueezy-integration migration

/tests/unit/lib/lemonsqueezy/
  ├── client.test.ts                         # CREATE: Client tests
  └── webhookHandlers/
      ├── subscriptionCreated.test.ts        # CREATE: Handler tests
      ├── subscriptionPaymentSuccess.test.ts
      └── subscriptionCancelled.test.ts

/tests/integration/api/
  ├── checkout/
  │   └── pro.test.ts                        # CREATE: Checkout endpoint tests
  └── webhooks/
      └── lemonsqueezy.test.ts               # CREATE: Webhook endpoint tests

/tests/integration/lemonsqueezy/
  └── usageReporting.test.ts                 # CREATE: Usage reporting tests
```

**Files to Modify:**
```
/components/features/upgrade/
  └── UpgradeModal.tsx                       # MODIFY: Replace placeholder CTAs with real handlers

/app/api/interpret/
  └── route.ts                               # MODIFY: Add usage reporting for PAYG users

/prisma/
  └── schema.prisma                          # MODIFY: Add Subscription, LemonSqueezyEvent tables

/.env.local.example                          # MODIFY: Add Lemon Squeezy environment variables

/package.json                                # MODIFY: Add @lemonsqueezy/lemonsqueezy.js
```

[Source: docs/architecture/12-unified-project-structure.md]

---

### Relevant Source Tree

```
towerofbabel/
├── app/
│   ├── (dashboard)/
│   │   └── checkout/
│   │       ├── success/page.tsx            # CREATE: Success page
│   │       └── cancelled/page.tsx          # CREATE: Cancelled page
│   └── api/
│       ├── checkout/
│       │   └── pro/
│       │       └── route.ts                # CREATE: Pro checkout endpoint
│       ├── subscription/
│       │   └── payg/
│       │       └── create/
│       │           └── route.ts            # CREATE: PAYG subscription endpoint
│       ├── webhooks/
│       │   └── lemonsqueezy/
│       │       └── route.ts                # CREATE: Webhook handler
│       └── interpret/
│           └── route.ts                    # MODIFY: Add usage reporting
├── components/
│   └── features/
│       └── upgrade/
│           └── UpgradeModal.tsx            # MODIFY: Replace placeholder CTAs
├── lib/
│   ├── lemonsqueezy/
│   │   ├── client.ts                       # CREATE: SDK setup
│   │   ├── usageReporting.ts               # CREATE: Usage reporting
│   │   └── webhookHandlers/
│   │       ├── subscriptionCreated.ts      # CREATE
│   │       ├── subscriptionPaymentSuccess.ts # CREATE
│   │       └── subscriptionCancelled.ts    # CREATE
│   └── db/
│       └── prisma.ts                       # EXISTING: Use for transactions
├── prisma/
│   ├── schema.prisma                       # MODIFY: Add Subscription, LemonSqueezyEvent
│   └── migrations/                         # CREATE: add-lemonsqueezy-integration
├── tests/
│   ├── unit/
│   │   └── lib/
│   │       └── lemonsqueezy/
│   │           ├── client.test.ts          # CREATE
│   │           └── webhookHandlers/
│   │               ├── subscriptionCreated.test.ts
│   │               ├── subscriptionPaymentSuccess.test.ts
│   │               └── subscriptionCancelled.test.ts
│   └── integration/
│       ├── api/
│       │   ├── checkout/
│       │   │   └── pro.test.ts             # CREATE
│       │   └── webhooks/
│       │       └── lemonsqueezy.test.ts    # CREATE
│       └── lemonsqueezy/
│           └── usageReporting.test.ts      # CREATE
├── .env.local.example                      # MODIFY: Add Lemon Squeezy config
└── package.json                            # MODIFY: Add @lemonsqueezy/lemonsqueezy.js
```

---

### Testing Strategy

**Unit Tests (Target: 80% Coverage):**

1. **Lemon Squeezy Client Tests** (`client.test.ts`):
   - configureLemonSqueezy() sets up API client
   - getLemonSqueezyConfig() returns correct config for test/production mode
   - Throws error if API key not configured

2. **Webhook Handler Tests** (3 test files):
   - subscriptionCreated: Creates subscription, updates tier, resets usage (Pro)
   - subscriptionPaymentSuccess: Resets usage for Pro users
   - subscriptionCancelled: Downgrades user to trial
   - Mock Prisma transactions

**Integration Tests (Target: 60% Coverage):**

3. **Checkout Endpoint Tests** (`pro.test.ts`):
   - Returns 401 for unauthenticated requests
   - Creates checkout session for authenticated user
   - Returns checkout URL
   - Mock Lemon Squeezy createCheckout API

4. **Webhook Endpoint Tests** (`lemonsqueezy.test.ts`):
   - Returns 401 for missing/invalid signature
   - Processes subscription_created, subscription_payment_success, subscription_cancelled
   - Idempotency: Duplicate events skipped
   - Mock webhook payloads with valid signatures

5. **Usage Reporting Tests** (`usageReporting.test.ts`):
   - Reports usage to Lemon Squeezy for PAYG user
   - Idempotency: Same interpretation_id doesn't double-charge
   - Non-blocking: Interpretation succeeds even if reporting fails
   - Mock Lemon Squeezy reportUsage API

**Manual Testing Scenarios:**

6. **Pro Subscription Flow (Test Mode):**
   - Click "Subscribe to Pro" → redirects to Lemon Squeezy checkout
   - Complete checkout with test card (4242 4242 4242 4242)
   - Verify redirect to success page
   - Verify webhook fires, user tier updated to 'pro'
   - Verify usage counter reset to 0

7. **PAYG Activation Flow:**
   - Click "Start Pay-As-You-Go" → no payment required
   - Verify tier updated to 'payg' immediately
   - Submit interpretation → verify usage reported to Lemon Squeezy
   - Check Lemon Squeezy dashboard for usage event

8. **Webhook Security Testing:**
   - Send webhook with valid signature → 200 response
   - Send webhook with invalid signature → 401 response
   - Send duplicate webhook → duplicate detected

9. **Subscription Cancellation:**
   - Cancel Pro subscription in Lemon Squeezy dashboard
   - Verify webhook fires, user downgraded to trial
   - Verify user blocked by trial limits

**Testing Framework:**
- **Unit Tests:** Vitest + mocked Lemon Squeezy SDK
- **Integration Tests:** Vitest + Supertest + mocked Lemon Squeezy API
- **Manual Tests:** Lemon Squeezy test mode + test cards

[Source: docs/architecture/16-coding-standards.md#testing-standards, docs/architecture/3-tech-stack.md]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Story created with Lemon Squeezy integration for subscriptions and metered billing | Scrum Master (Bob) |
| 2025-10-26 | 1.1 | Applied PO validation fixes: Added Sarah's 7 recommended test tasks (Tasks 27-33) | Scrum Master (Bob) |
| 2025-10-26 | 2.0 | Enhanced test coverage to 95%+ code coverage target: Added 17 comprehensive test tasks (Tasks 34-50) covering concurrency, lifecycle, error recovery, PAYG aggregation, data consistency, edge cases, retry logic, E2E flows, performance, billing periods, status transitions, security, customer ID management, payload validation, reactivation, and production readiness. Updated Task 22 with payment failure scenario. Validation score increased to 9.5/10. | Scrum Master (Bob) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_

---
