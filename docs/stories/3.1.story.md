# Story 3.1: Implement Usage Limit Enforcement Logic

<!-- Powered by BMAD™ Core -->

## Status

**Draft**

---

## Story

**As a** user,
**I want** my interpretation usage tracked and limits enforced based on my tier,
**so that** I understand my usage and am prompted to upgrade when limits are reached.

---

## Acceptance Criteria

1. Trial tier enforcement: Block interpretations when messages_used_count ≥10 OR 14 days elapsed since account creation
2. Pro tier enforcement: Block interpretations when messages_used_count ≥ configured limit (TBD)
3. Pay-as-you-go tier: No limit enforcement (will charge per use via Lemon Squeezy)
4. API route /api/interpret checks tier and limits before processing LLM call
5. Limit exceeded error returns 403 status with message: `{"error": "limit_exceeded", "tier": "trial", "messages_used": 10}`
6. Usage counter reset logic: Pro tier resets messages_used_count to 0 when current_period_end reached (monthly billing cycle)
7. Trial tier does NOT reset (one-time 10 message limit)
8. Database field messages_reset_date tracks next reset date for Pro users
9. Background job or API endpoint handles monthly usage resets (cron job or Vercel cron)
10. Unit tests for limit checking logic across all tiers

---

## Tasks / Subtasks

- [ ] **Task 1: Enhance usageService with Trial Expiration Logic** (AC: 1)
  - [ ] Add `checkTrialExpired(user)` function to `/lib/services/usageService.ts`
  - [ ] Calculate days since account creation: `Date.now() - user.trial_start_date`
  - [ ] Return `{ expired: true, daysElapsed: 15 }` if > 14 days
  - [ ] Update `checkUsageLimit()` to call `checkTrialExpired()` for trial users
  - [ ] Block interpretations if trial expired OR messages ≥ 10
  - [ ] Return error with expiration details: `{ code: 'TRIAL_EXPIRED', daysElapsed: 15 }`

- [ ] **Task 2: Add Database Migration for messages_reset_date** (AC: 8)
  - [ ] Check if `messages_reset_date` field exists in `prisma/schema.prisma`
  - [ ] If not exists, add field:
    ```prisma
    model User {
      // ... existing fields
      messages_reset_date  DateTime?  // Next reset date for Pro users
    }
    ```
  - [ ] Run migration: `npx prisma migrate dev --name add-messages-reset-date`
  - [ ] Update existing Pro users to set initial `messages_reset_date`:
    - **If user has active subscription:** Set to `subscription.current_period_end` from Lemon Squeezy
    - **If no subscription data available yet:** Set to `Date.now() + 30 days` (first monthly cycle)
    - **If user is still trial or PAYG:** Leave as NULL (no reset needed)
    - Create data migration script or manual UPDATE query:
      ```sql
      -- Example for users without subscription data yet
      UPDATE users
      SET messages_reset_date = NOW() + INTERVAL '30 days'
      WHERE tier = 'pro' AND messages_reset_date IS NULL;
      ```
    - Run migration: `npx prisma db seed` or execute SQL directly
    - Document migration execution in Dev Agent Record

- [ ] **Task 3: Add Pro Tier Monthly Reset Logic** (AC: 6, 8)
  - [ ] Add `shouldResetUsage(user)` function to `/lib/services/usageService.ts`
  - [ ] Check if Pro user and `Date.now() > user.messages_reset_date`
  - [ ] If reset needed, call `resetProUserUsage(userId)` function
  - [ ] Create `resetProUserUsage()` function in `/lib/db/repositories/userRepository.ts`:
    - Reset `messages_used_count` to 0
    - Update `messages_reset_date` to `current_period_end + 1 month`
    - Log reset event for audit trail
  - [ ] Wrap in connection circuit breaker
  - [ ] Add JSDoc documentation [Source: architecture/16-coding-standards.md#jsdoc-for-public-apis]

- [ ] **Task 4: Enhance Error Responses with Usage Details** (AC: 5)
  - [ ] Update `/app/api/interpret/route.ts` error handling
  - [ ] For trial limit exceeded:
    ```typescript
    {
      success: false,
      error: {
        code: 'LIMIT_EXCEEDED',
        message: 'Trial limit reached (10 messages)',
        tier: 'trial',
        messages_used: 10,
        messages_limit: 10
      }
    }
    ```
  - [ ] For trial expired:
    ```typescript
    {
      success: false,
      error: {
        code: 'TRIAL_EXPIRED',
        message: 'Trial period expired (14 days)',
        tier: 'trial',
        days_elapsed: 15,
        trial_end_date: '2025-11-05T00:00:00Z'
      }
    }
    ```
  - [ ] For Pro limit exceeded:
    ```typescript
    {
      success: false,
      error: {
        code: 'LIMIT_EXCEEDED',
        message: 'Monthly limit reached (100 messages)',
        tier: 'pro',
        messages_used: 100,
        messages_limit: 100,
        reset_date: '2025-11-01T00:00:00Z'
      }
    }
    ```

- [ ] **Task 5: Create Vercel Cron Job for Monthly Resets** (AC: 9)
  - [ ] Create `/app/api/cron/reset-usage/route.ts` API endpoint
  - [ ] Add Vercel Cron configuration in `vercel.json`:
    ```json
    {
      "crons": [{
        "path": "/api/cron/reset-usage",
        "schedule": "0 0 * * *"  // Daily at midnight UTC
      }]
    }
    ```
    [Source: https://vercel.com/docs/cron-jobs#configuration]
  - [ ] Endpoint logic:
    - Query all Pro users where `messages_reset_date <= Date.now()`
    - For each user, call `resetProUserUsage(userId)`
    - Return count of users reset: `{ reset_count: 5, timestamp: ... }`
  - [ ] Add authorization check (Vercel Cron secret header)
  - [ ] Add structured logging for audit trail
  - [ ] Add error handling and retry logic

- [ ] **Task 6: Add Environment Variables for Limits** (AC: 2)
  - [ ] Update `.env.local.example` with configurable limits:
    ```bash
    # Usage Limits
    TRIAL_MESSAGE_LIMIT=10
    TRIAL_DAYS_LIMIT=14
    PRO_MESSAGE_LIMIT=100  # TBD based on pricing analysis
    ```
  - [ ] Read limits from environment in usageService
  - [ ] Add fallback defaults if env vars not set
  - [ ] Document in README or lib/services/usageService.ts comments

- [ ] **Task 7: Update API Route with Enhanced Limit Checking** (AC: 4)
  - [ ] Update `/app/api/interpret/route.ts` usage check section
  - [ ] Call enhanced `checkUsageLimit()` with trial expiration and reset logic
  - [ ] Handle new error codes: `TRIAL_EXPIRED`, `LIMIT_EXCEEDED` with details
  - [ ] Ensure database-as-source-of-truth pattern maintained
  - [ ] Log limit exceeded events for analytics

- [ ] **Task 8: Write Unit Tests for Trial Expiration Logic**
  - [ ] Create `/tests/unit/lib/services/usageService-trial-expiration.test.ts`
  - [ ] Test: Trial user 5 days old → allowed
  - [ ] Test: Trial user 14 days old → allowed (edge case)
  - [ ] Test: Trial user 15 days old → blocked (TRIAL_EXPIRED)
  - [ ] Test: Trial user with 10 messages used → blocked (LIMIT_EXCEEDED)
  - [ ] Test: Trial user 15 days old + 5 messages → blocked (TRIAL_EXPIRED takes precedence)
  - [ ] Mock Prisma queries with different trial_start_date values
  - [ ] Use Vitest [Source: architecture/3-tech-stack.md]

- [ ] **Task 9: Write Unit Tests for Pro Reset Logic**
  - [ ] Create `/tests/unit/lib/services/usageService-pro-reset.test.ts`
  - [ ] Test: Pro user before reset date → no reset
  - [ ] Test: Pro user after reset date → usage reset to 0
  - [ ] Test: Pro user reset updates messages_reset_date to next month
  - [ ] Test: Reset logic only applies to Pro tier (not trial or PAYG)
  - [ ] Mock Prisma update operations
  - [ ] Verify audit logging

- [ ] **Task 10: Write Integration Tests for Cron Job**
  - [ ] Create `/tests/integration/api/cron/reset-usage.test.ts`
  - [ ] Test: Cron job resets multiple Pro users
  - [ ] Test: Cron job skips users not due for reset
  - [ ] Test: Cron job authorization (Vercel Cron secret header)
  - [ ] Test: Cron job returns correct reset count
  - [ ] Mock database with test Pro users
  - [ ] Use Supertest for HTTP assertions [Source: architecture/3-tech-stack.md]

- [ ] **Task 11: Write Integration Tests for Enhanced API Error Responses**
  - [ ] Update `/tests/integration/api/interpret.test.ts`
  - [ ] Test: Trial user at 10 messages → 403 with LIMIT_EXCEEDED + usage details
  - [ ] Test: Trial user expired → 403 with TRIAL_EXPIRED + days elapsed
  - [ ] Test: Pro user at limit → 403 with LIMIT_EXCEEDED + reset_date
  - [ ] Test: Pro user after reset_date → usage auto-resets, interpretation allowed
  - [ ] Verify error response includes all required fields
  - [ ] Mock time-based logic with date mocking

- [ ] **Task 12: Manual Testing of Trial Expiration**
  - [ ] Create test user with trial_start_date 15 days ago
  - [ ] Attempt interpretation → verify 403 TRIAL_EXPIRED error
  - [ ] Verify error includes days_elapsed field
  - [ ] Create test user with trial_start_date 5 days ago, 10 messages used
  - [ ] Attempt interpretation → verify 403 LIMIT_EXCEEDED error
  - [ ] Verify both error conditions work independently

- [ ] **Task 13: Manual Testing of Pro Reset Logic**
  - [ ] Create test Pro user with messages_used_count = 50
  - [ ] Set messages_reset_date to yesterday
  - [ ] Attempt interpretation → verify usage auto-resets to 0
  - [ ] Verify interpretation succeeds after reset
  - [ ] Check database: messages_used_count = 1, messages_reset_date updated

- [ ] **Task 14: Manual Testing of Cron Job**
  - [ ] Deploy to Vercel staging
  - [ ] Manually trigger cron: `curl -X POST https://staging.towerofbabel.vercel.app/api/cron/reset-usage -H "Authorization: Bearer $CRON_SECRET"`
  - [ ] Verify Pro users reset correctly
  - [ ] Check logs for reset count
  - [ ] Verify non-Pro users unaffected

- [ ] **Task 15: Build and Lint Validation**
  - [ ] Run TypeScript compilation: `npx tsc --noEmit`
  - [ ] Verify no TypeScript errors
  - [ ] Run ESLint: `npm run lint`
  - [ ] Verify no ESLint errors (warnings acceptable)
  - [ ] Run unit tests: `npm test tests/unit/lib/services`
  - [ ] Run integration tests: `npm test tests/integration`
  - [ ] Verify all tests pass

- [ ] **Task 16: Commit Changes**
  - [ ] Stage all changes: `git add .`
  - [ ] Commit with conventional commit message: `feat(usage): add trial expiration and Pro tier reset logic (Story 3.1)` [Source: architecture/16-coding-standards.md#conventional-commits]
  - [ ] Push to GitHub: `git push origin main`
  - [ ] Verify CI pipeline passes

---

## Dev Notes

### Story Context and Integration

**This story enhances the usage limit enforcement system with trial expiration and Pro tier reset logic.**

**Integration Flow:**
- Story 2.3: Created basic usage limit checking (trial: 10, pro: 100, payg: unlimited) (DONE)
- **Story 3.1 (THIS STORY):** Add trial expiration (14 days) + Pro tier monthly resets
- Story 3.2: Display usage indicator in UI with notifications
- Story 3.3: Create upgrade modal with pricing tiers
- Story 3.4: Integrate Lemon Squeezy for payments

**Key Insights from Story 2.3:**
- `usageService.ts` already exists with `checkUsageLimit()` function
- Database-as-source-of-truth pattern enforced (queries DB for tier/usage, NOT JWT)
- Error responses use standardized format: `{ success: false, error: { code, message } }`
- Trial limit: 10 messages
- Pro limit: 100 messages (TBD, may change)
- PAYG: No limit enforcement

**What Story 3.1 Adds:**
- ✨ **NEW:** Trial expiration check (14 days from trial_start_date)
- ✨ **NEW:** Pro tier automatic usage reset (when messages_reset_date reached)
- ✨ **NEW:** Vercel Cron job for daily reset processing
- ✨ **NEW:** Enhanced error responses with usage details
- ✨ **NEW:** Environment variable configuration for limits

---

### CRITICAL Architectural Patterns (Continued from Story 2.3)

#### Database as Source of Truth (Risk Mitigation #1)

**This pattern is MANDATORY and already enforced in Story 2.3.**

Story 3.1 EXTENDS this pattern by adding:
- Trial expiration check via `user.trial_start_date` from database
- Pro reset check via `user.messages_reset_date` from database

```typescript
// ✅ CORRECT - Query database for user record
const userRecord = await prisma.user.findUnique({
  where: { id: user.id },
  select: {
    tier: true,
    messages_used_count: true,
    messages_reset_date: true,  // NEW: For Pro reset logic
    trial_start_date: true       // NEW: For trial expiration logic
  }
});

// Check trial expiration (NEW in Story 3.1)
if (userRecord.tier === 'trial') {
  const daysElapsed = (Date.now() - userRecord.trial_start_date.getTime()) / (1000 * 60 * 60 * 24);
  if (daysElapsed > 14) {
    return { allowed: false, error: { code: 'TRIAL_EXPIRED', daysElapsed } };
  }
}

// Check Pro reset (NEW in Story 3.1)
if (userRecord.tier === 'pro' && userRecord.messages_reset_date) {
  if (Date.now() > userRecord.messages_reset_date.getTime()) {
    await resetProUserUsage(user.id);  // Auto-reset usage
  }
}
```

[Source: architecture/14-critical-risk-mitigation.md#risk-1, docs/stories/2.3.story.md]

---

### Usage Limit Enforcement Logic

**Trial Tier (AC: 1, 7):**

**Conditions for blocking:**
1. `messages_used_count >= 10` (message limit)
2. OR `(Date.now() - trial_start_date) > 14 days` (time limit)

**Logic:**
```typescript
function checkTrialLimit(user: User): UsageCheckResult {
  // Check message limit
  if (user.messages_used_count >= TRIAL_MESSAGE_LIMIT) {
    return {
      allowed: false,
      error: {
        code: 'LIMIT_EXCEEDED',
        message: 'Trial limit reached (10 messages)',
        tier: 'trial',
        messages_used: user.messages_used_count,
        messages_limit: TRIAL_MESSAGE_LIMIT
      }
    };
  }

  // Check time limit (NEW in Story 3.1)
  const daysElapsed = (Date.now() - user.trial_start_date.getTime()) / (1000 * 60 * 60 * 24);
  if (daysElapsed > TRIAL_DAYS_LIMIT) {
    return {
      allowed: false,
      error: {
        code: 'TRIAL_EXPIRED',
        message: `Trial period expired (${TRIAL_DAYS_LIMIT} days)`,
        tier: 'trial',
        days_elapsed: Math.floor(daysElapsed),
        trial_end_date: new Date(user.trial_start_date.getTime() + TRIAL_DAYS_LIMIT * 24 * 60 * 60 * 1000).toISOString()
      }
    };
  }

  return {
    allowed: true,
    messages_remaining: TRIAL_MESSAGE_LIMIT - user.messages_used_count
  };
}
```

**Why both conditions:**
- Users who send 10 messages quickly (in 1 day) hit message limit
- Users who sign up but don't use much hit time limit (14 days)
- Prevents abuse of extended trial period

**Trial does NOT reset** - one-time 10 message limit, period expires after 14 days.

---

**Pro Tier (AC: 2, 6, 8):**

**Conditions for blocking:**
1. `messages_used_count >= PRO_MESSAGE_LIMIT` (e.g., 100)
2. AND `Date.now() < messages_reset_date` (not yet reset time)

**Automatic reset logic:**
- When `Date.now() > messages_reset_date`:
  - Set `messages_used_count = 0`
  - Set `messages_reset_date = current_period_end + 1 month`
  - Log reset event

**Logic:**
```typescript
async function checkProLimit(user: User): Promise<UsageCheckResult> {
  // Check if reset needed (NEW in Story 3.1)
  if (user.messages_reset_date && Date.now() > user.messages_reset_date.getTime()) {
    await resetProUserUsage(user.id);
    // After reset, user has full quota available
    return {
      allowed: true,
      messages_remaining: PRO_MESSAGE_LIMIT
    };
  }

  // Check message limit
  if (user.messages_used_count >= PRO_MESSAGE_LIMIT) {
    return {
      allowed: false,
      error: {
        code: 'LIMIT_EXCEEDED',
        message: `Monthly limit reached (${PRO_MESSAGE_LIMIT} messages)`,
        tier: 'pro',
        messages_used: user.messages_used_count,
        messages_limit: PRO_MESSAGE_LIMIT,
        reset_date: user.messages_reset_date?.toISOString()
      }
    };
  }

  return {
    allowed: true,
    messages_remaining: PRO_MESSAGE_LIMIT - user.messages_used_count
  };
}
```

**Why automatic reset:**
- Avoids manual intervention
- Seamless user experience (no downtime)
- Checked on every interpretation request (real-time)
- Backup: Vercel Cron job runs daily to catch missed resets

---

**Pay-As-You-Go Tier (AC: 3):**

**No limit enforcement** - user pays $0.50 per interpretation via Lemon Squeezy.

```typescript
function checkPAYGLimit(user: User): UsageCheckResult {
  // Always allowed (will be charged via Lemon Squeezy)
  return {
    allowed: true,
    messages_remaining: undefined  // No limit
  };
}
```

[Source: docs/prd/epic-3-usage-tracking-pricing-tiers.md]

---

### Vercel Cron Job Configuration

**Purpose:** Daily background job to reset Pro users who reached their monthly reset date.

**Why Cron Job:**
- Primary: Automatic reset happens on-demand during interpretation request
- Backup: Cron job catches users who don't make requests on reset day
- Audit: Centralized logging of all resets

**Configuration (vercel.json):**
```json
{
  "crons": [{
    "path": "/api/cron/reset-usage",
    "schedule": "0 0 * * *"  // Daily at midnight UTC
  }]
}
```

**Endpoint Implementation:**
```typescript
// /app/api/cron/reset-usage/route.ts
export async function POST(req: NextRequest) {
  // 1. Authorization - Verify Vercel Cron secret
  const authHeader = req.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // 2. Query Pro users due for reset
  const now = new Date();
  const usersToReset = await prisma.user.findMany({
    where: {
      tier: 'pro',
      messages_reset_date: {
        lte: now  // Reset date has passed
      }
    },
    select: { id: true, messages_reset_date: true }
  });

  // 3. Reset each user
  let resetCount = 0;
  for (const user of usersToReset) {
    try {
      await resetProUserUsage(user.id);
      resetCount++;
    } catch (error) {
      logger.error('Failed to reset user', { userId: user.id, error });
    }
  }

  // 4. Log and return result
  logger.info('Cron job completed', {
    reset_count: resetCount,
    timestamp: now.toISOString()
  });

  return NextResponse.json({
    success: true,
    reset_count: resetCount,
    timestamp: now.toISOString()
  });
}
```

**Security:**
- Vercel Cron automatically adds `Authorization: Bearer $CRON_SECRET` header
- Endpoint validates this header to prevent unauthorized access
- Add `CRON_SECRET` to environment variables

[Source: architecture/3-tech-stack.md, https://vercel.com/docs/cron-jobs]

---

### Database Schema Updates

**New Field: `messages_reset_date` (AC: 8)**

```prisma
model User {
  id                        String          @id @default(uuid())
  email                     String          @unique
  tier                      String          @default("trial") // 'trial' | 'payg' | 'pro'
  messages_used_count       Int             @default(0)
  messages_reset_date       DateTime?       // NEW: Next reset date for Pro users
  trial_start_date          DateTime        @default(now())
  // ... other fields
}
```

**Purpose:**
- Tracks when Pro user's usage should reset (monthly billing cycle)
- Set to `current_period_end` from Lemon Squeezy subscription
- Updated on each reset to next month
- NULL for trial and PAYG users (they don't reset)

**Initial Value:**
- Trial users: NULL (no reset)
- PAYG users: NULL (no reset)
- Pro users: Set when subscription created (Story 3.4 webhook)

**Migration:**
```bash
npx prisma migrate dev --name add-messages-reset-date
```

[Source: architecture/4-data-models.md]

---

### Error Response Format Enhancement

**Trial Limit Exceeded (AC: 5):**
```typescript
{
  success: false,
  error: {
    code: 'LIMIT_EXCEEDED',
    message: 'Trial limit reached (10 messages)',
    tier: 'trial',
    messages_used: 10,
    messages_limit: 10
  }
}
```

**Trial Expired (NEW in Story 3.1):**
```typescript
{
  success: false,
  error: {
    code: 'TRIAL_EXPIRED',
    message: 'Trial period expired (14 days)',
    tier: 'trial',
    days_elapsed: 15,
    trial_end_date: '2025-11-05T00:00:00Z'
  }
}
```

**Pro Limit Exceeded (AC: 5):**
```typescript
{
  success: false,
  error: {
    code: 'LIMIT_EXCEEDED',
    message: 'Monthly limit reached (100 messages)',
    tier: 'pro',
    messages_used: 100,
    messages_limit: 100,
    reset_date: '2025-11-01T00:00:00Z'  // When usage will reset
  }
}
```

**Why Enhanced Errors:**
- UI can display exact usage details to user
- Frontend knows when reset happens (for Pro users)
- Clear differentiation between message limit and time limit
- Enables better upgrade prompts in UI (Story 3.2, 3.3)

[Source: architecture/16-coding-standards.md#api-response-format]

---

### Environment Variables Configuration

**New Variables (AC: 5):**

```bash
# Usage Limits (configurable)
TRIAL_MESSAGE_LIMIT=10
TRIAL_DAYS_LIMIT=14
PRO_MESSAGE_LIMIT=100  # TBD based on pricing analysis

# Cron Job Security
CRON_SECRET=your_secret_here  # Vercel Cron authorization
```

**Usage in Code:**
```typescript
// /lib/services/usageService.ts
const TRIAL_MESSAGE_LIMIT = parseInt(process.env.TRIAL_MESSAGE_LIMIT || '10');
const TRIAL_DAYS_LIMIT = parseInt(process.env.TRIAL_DAYS_LIMIT || '14');
const PRO_MESSAGE_LIMIT = parseInt(process.env.PRO_MESSAGE_LIMIT || '100');
```

**Why Configurable:**
- Easy to adjust limits without code changes
- Different limits for development vs production
- A/B testing different trial durations
- Quick response to unit economics analysis

[Source: architecture/3-tech-stack.md]

---

### File Locations and Project Structure

**Files to Modify:**
```
/lib/services/
  └── usageService.ts                    # MODIFY: Add trial expiration + Pro reset logic

/lib/db/repositories/
  └── userRepository.ts                  # MODIFY: Add resetProUserUsage() function

/app/api/interpret/
  └── route.ts                           # MODIFY: Enhanced error responses with usage details

/prisma/
  └── schema.prisma                      # MODIFY: Add messages_reset_date field (if not exists)
```

**Files to Create:**
```
/app/api/cron/reset-usage/
  └── route.ts                           # CREATE: Vercel Cron endpoint for daily resets

/tests/unit/lib/services/
  ├── usageService-trial-expiration.test.ts  # CREATE: Trial expiration tests
  └── usageService-pro-reset.test.ts         # CREATE: Pro reset logic tests

/tests/integration/api/cron/
  └── reset-usage.test.ts                # CREATE: Cron job integration tests

/vercel.json                             # MODIFY: Add cron configuration
```

[Source: architecture/12-unified-project-structure.md]

---

### Relevant Source Tree

```
towerofbabel/
├── app/
│   └── api/
│       ├── interpret/
│       │   └── route.ts                  # EXISTING (Story 2.3) - MODIFY: Enhanced errors
│       └── cron/
│           └── reset-usage/
│               └── route.ts              # CREATE: Daily reset cron job
├── lib/
│   ├── services/
│   │   └── usageService.ts              # EXISTING (Story 2.3) - MODIFY: Add expiration + reset
│   └── db/
│       └── repositories/
│           └── userRepository.ts        # EXISTING (Story 2.3) - MODIFY: Add resetProUserUsage()
├── prisma/
│   ├── schema.prisma                    # MODIFY: Add messages_reset_date field
│   └── migrations/                      # NEW MIGRATION: add-messages-reset-date
├── tests/
│   ├── unit/
│   │   └── lib/
│   │       └── services/
│   │           ├── usageService.test.ts               # EXISTING (Story 2.3)
│   │           ├── usageService-trial-expiration.test.ts  # CREATE
│   │           └── usageService-pro-reset.test.ts         # CREATE
│   └── integration/
│       └── api/
│           ├── interpret.test.ts         # EXISTING (Story 2.3) - MODIFY: New error tests
│           └── cron/
│               └── reset-usage.test.ts   # CREATE
├── .env.local.example                   # MODIFY: Add TRIAL_DAYS_LIMIT, CRON_SECRET
└── vercel.json                          # MODIFY: Add cron configuration
```

---

### Testing Strategy

**Unit Tests (Target: 80% Coverage):**

1. **Trial Expiration Tests** (`usageService-trial-expiration.test.ts`):
   - Trial user 5 days old, 5 messages → allowed
   - Trial user 14 days old → allowed (edge case)
   - Trial user 15 days old → blocked (TRIAL_EXPIRED)
   - Trial user 10 messages, 5 days old → blocked (LIMIT_EXCEEDED)
   - Trial user 15 days old + 10 messages → blocked (TRIAL_EXPIRED priority)

2. **Pro Reset Tests** (`usageService-pro-reset.test.ts`):
   - Pro user before reset_date → no reset
   - Pro user after reset_date → usage reset to 0
   - Reset updates messages_reset_date to next month
   - Reset only applies to Pro tier
   - Audit logging verification

**Integration Tests (Target: 60% Coverage):**

3. **Cron Job Tests** (`reset-usage.test.ts`):
   - Cron resets multiple Pro users
   - Cron skips users not due for reset
   - Cron authorization (Vercel secret header)
   - Cron returns correct reset count
   - Error handling for failed resets

4. **Enhanced API Error Tests** (update `interpret.test.ts`):
   - Trial user at 10 messages → 403 with LIMIT_EXCEEDED + details
   - Trial user expired → 403 with TRIAL_EXPIRED + days_elapsed
   - Pro user at limit → 403 with LIMIT_EXCEEDED + reset_date
   - Pro user after reset → usage auto-resets, interpretation allowed

**Testing Framework:**
- **Unit Tests:** Vitest with mocked Prisma + date mocking
- **Integration Tests:** Vitest + Supertest with test database

**Date Mocking:**
```typescript
import { vi } from 'vitest';

// Mock Date.now() to control time-based logic
const mockDate = new Date('2025-10-22T00:00:00Z');
vi.spyOn(Date, 'now').mockReturnValue(mockDate.getTime());
```

[Source: architecture/16-coding-standards.md#testing-standards, architecture/3-tech-stack.md]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-22 | 1.0 | Story created with trial expiration and Pro reset logic implementation | Scrum Master (Bob) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_

---
