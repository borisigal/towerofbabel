# Story 2.1: Build Interpretation Form UI with Culture Selectors

<!-- Powered by BMAD™ Core -->

## Status

**Draft**

---

## Story

**As a** user,
**I want** to paste a message and select sender/receiver cultures,
**so that** I can request an interpretation of what the message really means.

---

## Acceptance Criteria

1. Interpretation form displayed on dashboard with large textarea (placeholder: "Paste the message you want to interpret...")
2. Real-time character counter displays "X / 2,000 characters" below textarea
3. Character counter turns red/warning color when >2,000 characters
4. Submit button disabled when character count exceeds 2,000 with tooltip message: "Message too long. Please shorten to 2,000 characters or less."
5. Two culture dropdown selectors: "Sender's Culture" and "Receiver's Culture"
6. Each dropdown populated with 15 cultures: American, British, German, French, Japanese, Chinese, Indian, Spanish, Italian, Dutch, Korean, Brazilian, Mexican, Australian, Canadian
7. Same-culture selection allowed (e.g., American → American)
8. "Interpret" button enabled when form is valid (message length ≤2,000, both cultures selected)
9. Loading state displays when interpretation request submitted (button shows spinner, form disabled)
10. Form is fully responsive (works on mobile, tablet, desktop)

---

## Tasks / Subtasks

- [ ] **Task 1: Create Interpretation Form Component** (AC: 1, 8)
  - [ ] Create `/components/features/interpretation/InterpretationForm.tsx` as Client Component [Source: architecture/16-coding-standards.md#server-components-by-default, architecture/10-frontend-architecture.md]
  - [ ] Add `'use client'` directive at top (requires event handlers, state)
  - [ ] Use React Hook Form for form state management (lightweight, validation support)
  - [ ] Create form schema with TypeScript interface matching InterpretationRequest type [Source: architecture/4-data-models.md#shared-typescript-types]
    ```typescript
    interface InterpretationFormData {
      message: string;
      sender_culture: CultureCode;
      receiver_culture: CultureCode;
    }
    ```
  - [ ] Implement form submission handler (preventDefault, validation, loading state management)
  - [ ] Add JSDoc comment explaining component purpose and usage [Source: architecture/16-coding-standards.md#jsdoc-for-public-apis]

- [ ] **Task 2: Create Textarea with Character Counter** (AC: 1, 2, 3, 4)
  - [ ] Use shadcn/ui Textarea component as base (accessible, WCAG 2.1 AA compliant) [Source: architecture/3-tech-stack.md]
  - [ ] Set placeholder text: "Paste the message you want to interpret..."
  - [ ] Configure textarea to auto-resize (max 300px height) for better UX
  - [ ] Create CharacterCounter sub-component:
    - Display format: "X / 2,000 characters"
    - Use `watch()` from React Hook Form to track message length in real-time
    - Apply conditional styling: gray when <2000, red/warning when >2000
    - Use Tailwind CSS classes: `text-gray-600` (normal), `text-red-600 font-semibold` (warning) [Source: architecture/3-tech-stack.md]
  - [ ] Add maxLength validation (2000 chars)
  - [ ] Disable submit button when message.length > 2000
  - [ ] Add tooltip to disabled button: "Message too long. Please shorten to 2,000 characters or less."
  - [ ] Test with messages at 1999, 2000, 2001 characters to verify behavior

- [ ] **Task 3: Create Culture Selector Components** (AC: 5, 6, 7)
  - [ ] Create `/components/features/interpretation/CultureSelector.tsx` reusable component
  - [ ] Use shadcn/ui Select component for dropdowns (accessible, keyboard navigation) [Source: architecture/3-tech-stack.md]
  - [ ] Import CULTURE_NAMES constant from `/lib/types/models.ts` [Source: architecture/4-data-models.md#shared-typescript-types]
  - [ ] Populate dropdown with 15 cultures:
    ```typescript
    const cultures: CultureCode[] = [
      'american', 'british', 'german', 'french', 'japanese',
      'chinese', 'indian', 'spanish', 'italian', 'dutch',
      'korean', 'brazilian', 'mexican', 'australian', 'canadian'
    ];
    ```
  - [ ] Allow same-culture selection (e.g., American → American) - no validation restriction
  - [ ] Add clear labels: "Sender's Culture" and "Receiver's Culture"
  - [ ] Use PascalCase component props: `label`, `value`, `onChange`, `disabled`
  - [ ] Make selectors required fields (form validation)

- [ ] **Task 4: Implement Form Validation** (AC: 4, 8)
  - [ ] Add validation rules via React Hook Form:
    - Message: required, maxLength 2000
    - Sender culture: required
    - Receiver culture: required
  - [ ] Enable submit button ONLY when:
    - Message length > 0 AND ≤ 2000
    - Sender culture selected
    - Receiver culture selected
  - [ ] Add visual feedback for validation errors:
    - Red border on invalid fields
    - Error message below field (accessible, aria-describedby)
  - [ ] Test form validation with all edge cases

- [ ] **Task 5: Implement Loading State** (AC: 9)
  - [ ] Add `isLoading` state variable (useState hook)
  - [ ] When form submitted:
    - Set `isLoading = true`
    - Disable all form inputs (textarea, selectors, button)
    - Replace button text with spinner + "Interpreting..."
  - [ ] Use shadcn/ui Button component with loading prop [Source: architecture/3-tech-stack.md]
  - [ ] Add spinner icon (use Lucide React icons, e.g., `Loader2` with spin animation)
  - [ ] Restore form after response (success or error):
    - Set `isLoading = false`
    - Re-enable form inputs
  - [ ] Add aria-live region for screen reader updates during loading

- [ ] **Task 6: Implement Responsive Design** (AC: 10)
  - [ ] Use Tailwind CSS responsive breakpoints [Source: architecture/3-tech-stack.md, architecture/16-coding-standards.md]:
    - Mobile (<640px): Single column, full-width components, larger touch targets
    - Tablet (640-1024px): Single column, optimized spacing
    - Desktop (>1024px): Max width container (800px), centered layout
  - [ ] Test form layout on:
    - Mobile (375px width, iPhone SE)
    - Tablet (768px width, iPad)
    - Desktop (1440px width, standard laptop)
  - [ ] Ensure culture selectors stack vertically on mobile, side-by-side on desktop
  - [ ] Verify textarea resizes appropriately on all screen sizes
  - [ ] Check font sizes readable on mobile (min 16px to prevent zoom on iOS)

- [ ] **Task 7: Add Form to Dashboard Page** (AC: 1)
  - [ ] Open `/app/(dashboard)/dashboard/page.tsx` (created in Story 1.5A)
  - [ ] Replace placeholder interpretation form div with `<InterpretationForm />` component
  - [ ] Import InterpretationForm from `/components/features/interpretation/InterpretationForm`
  - [ ] Position form prominently at top of dashboard (above usage stats)
  - [ ] Verify form renders correctly in authenticated dashboard context

- [ ] **Task 8: Create Shared Types and Constants** (AC: 6)
  - [ ] Verify `/lib/types/models.ts` exists with CultureCode type [Source: architecture/4-data-models.md#shared-typescript-types]
  - [ ] If not exists, create file with:
    ```typescript
    export type CultureCode =
      | 'american' | 'british' | 'german' | 'french' | 'japanese'
      | 'chinese' | 'indian' | 'spanish' | 'italian' | 'dutch'
      | 'korean' | 'brazilian' | 'mexican' | 'australian' | 'canadian';

    export const CULTURE_NAMES: Record<CultureCode, string> = {
      american: 'American',
      british: 'British',
      german: 'German',
      french: 'French',
      japanese: 'Japanese',
      chinese: 'Chinese (Mandarin)',
      indian: 'Indian',
      spanish: 'Spanish',
      italian: 'Italian',
      dutch: 'Dutch',
      korean: 'Korean',
      brazilian: 'Brazilian Portuguese',
      mexican: 'Mexican',
      australian: 'Australian',
      canadian: 'Canadian',
    };

    export interface InterpretationRequest {
      message: string;
      sender_culture: CultureCode;
      receiver_culture: CultureCode;
      mode: 'inbound'; // Fixed for Story 2.1 (outbound mode in future epic)
    }
    ```
  - [ ] Export types for use in form validation

- [ ] **Task 9: Install shadcn/ui Components** (AC: 1, 5)
  - [ ] If not already installed, run shadcn/ui init: `npx shadcn-ui@latest init` [Source: architecture/3-tech-stack.md]
  - [ ] Install required components:
    - `npx shadcn-ui@latest add button` (for submit button)
    - `npx shadcn-ui@latest add select` (for culture dropdowns)
    - `npx shadcn-ui@latest add textarea` (for message input)
    - `npx shadcn-ui@latest add tooltip` (for disabled button hint)
  - [ ] Verify components copied to `/components/ui/` directory
  - [ ] Install Lucide React for icons: `npm install lucide-react` (spinner, dropdown icons)
  - [ ] Install React Hook Form: `npm install react-hook-form` (form state management)

- [ ] **Task 10: Write Component Unit Tests**
  - [ ] Create `/tests/unit/components/features/interpretation/InterpretationForm.test.tsx`
  - [ ] Test: Form renders with correct placeholder text
  - [ ] Test: Character counter updates in real-time as user types
  - [ ] Test: Character counter turns red when >2000 characters
  - [ ] Test: Submit button disabled when message empty
  - [ ] Test: Submit button disabled when message >2000 characters
  - [ ] Test: Submit button disabled when cultures not selected
  - [ ] Test: Submit button enabled when form valid (message ≤2000, cultures selected)
  - [ ] Test: Form enters loading state on submit (button shows spinner, inputs disabled)
  - [ ] Test: Culture selectors populated with all 15 cultures
  - [ ] Test: Same-culture selection allowed (e.g., American → American)
  - [ ] Test: Form submission calls onSubmit handler with correct data structure
  - [ ] Use React Testing Library with Vitest [Source: architecture/3-tech-stack.md, architecture/16-coding-standards.md#test-naming-convention]
  - [ ] Run tests: `npm test`

- [ ] **Task 11: Implement Accessibility (WCAG 2.1 AA)** (AC: 10)
  - [ ] Add proper ARIA labels to all form inputs:
    - `aria-label="Message to interpret"` on textarea
    - `aria-label="Sender's culture"` on first select
    - `aria-label="Receiver's culture"` on second select
  - [ ] Add `aria-describedby` linking character counter to textarea
  - [ ] Add `aria-live="polite"` to character counter for screen reader updates
  - [ ] Ensure keyboard navigation works:
    - Tab through all inputs in logical order
    - Enter submits form when button focused
    - Escape closes dropdowns
  - [ ] Verify color contrast ratios meet WCAG AA (4.5:1 for text, 3:1 for large text)
  - [ ] Test with screen reader (VoiceOver on Mac, NVDA on Windows)
  - [ ] Use shadcn/ui's built-in accessibility features (Radix UI primitives) [Source: architecture/3-tech-stack.md]

- [ ] **Task 12: Add Form Styling and Polish**
  - [ ] Apply consistent spacing with Tailwind classes (gap-4, space-y-4) [Source: architecture/3-tech-stack.md]
  - [ ] Add focus states for all interactive elements (ring-2, ring-primary)
  - [ ] Style submit button:
    - Primary color background (bg-primary, text-primary-foreground)
    - Full width on mobile, auto width on desktop
    - Disabled state: opacity-50, cursor-not-allowed
  - [ ] Add subtle border/shadow to form container for visual separation
  - [ ] Ensure consistent typography (font-sans, text-base)
  - [ ] Match dashboard design system from Story 1.5A

- [ ] **Task 13: Manual Testing on Real Devices**
  - [ ] Test on iPhone (Safari, mobile viewport)
  - [ ] Test on Android (Chrome, mobile viewport)
  - [ ] Test on iPad (Safari, tablet viewport)
  - [ ] Test on Desktop (Chrome, Firefox, Safari)
  - [ ] Verify form submission (currently no API, will show console log or temporary alert)
  - [ ] Test edge cases:
    - Paste message with exactly 2000 characters
    - Paste message with 2001 characters (should show warning)
    - Select same culture for sender and receiver
    - Submit form with all valid inputs
    - Attempt submit with invalid inputs (should be blocked)

- [ ] **Task 14: Integration Preparation for Story 2.3**
  - [ ] Add placeholder onSubmit handler that logs form data to console
  - [ ] Structure submission payload to match InterpretationRequest type [Source: architecture/4-data-models.md#shared-typescript-types]
  - [ ] Add TODO comment: "// TODO: Story 2.3 - Call /api/interpret endpoint"
  - [ ] Document expected API response format in component comments for Story 2.3 integration

- [ ] **Task 15: Build and Lint Validation**
  - [ ] Run TypeScript compilation: `npx tsc --noEmit`
  - [ ] Verify no TypeScript errors
  - [ ] Run ESLint: `npm run lint`
  - [ ] Verify no ESLint errors (warnings acceptable)
  - [ ] Run Prettier check: `npx prettier --check .`
  - [ ] Verify all files formatted correctly
  - [ ] Run unit tests: `npm test`
  - [ ] Verify all tests pass

- [ ] **Task 16: Commit and Deploy**
  - [ ] Commit changes with conventional commit message: `feat(interpretation): add interpretation form UI with culture selectors (Story 2.1)` [Source: architecture/16-coding-standards.md#conventional-commits]
  - [ ] Push to GitHub: `git push origin main`
  - [ ] Verify Vercel preview deployment successful
  - [ ] Test form in deployed preview environment
  - [ ] Verify responsive design in preview URL

---

## Dev Notes

### Previous Story Insights (Story 1.5C)

**Key Learnings from Story 1.5C** [Source: docs/stories/1.5C.story.md#dev-agent-record]:

1. **Pino Logger Signature**: Logger uses `logger.method(context, message)` signature (not `message, context`) [Source: Story 1.5C completion notes]
2. **TypeScript Safety**: Use defensive checks for potentially undefined values from array operations (e.g., `key.split(':')[2]` could be undefined)
3. **Authentication Pattern**: Supabase redirect URLs must exactly match dev server port (e.g., `http://localhost:3000/auth/callback`)
4. **Testing Strategy**: Mock functions need conditional logic to return different values based on input parameters for realistic test scenarios

**Critical Risk Mitigations in Place:**
- ✅ ESLint rule prevents JWT metadata usage (Story 1.1)
- ✅ Prisma connection pooling + circuit breaker (Story 1.3)
- ✅ Database-as-source-of-truth pattern documented (Story 1.4)
- ✅ LLM cost circuit breaker operational (Story 1.5C) - **Will be integrated in Story 2.3**

### Component Architecture

**Component Type: Client Component** [Source: architecture/16-coding-standards.md#server-components-by-default]

The InterpretationForm MUST be a Client Component because it requires:
- Event handlers (onChange, onSubmit)
- State management (useState for form data, loading state)
- Browser APIs (real-time validation, character counting)

```typescript
// ✅ CORRECT - Client Component
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';

export function InterpretationForm() {
  const [isLoading, setIsLoading] = useState(false);
  const { register, handleSubmit, watch } = useForm<InterpretationFormData>();

  // Event handlers and state logic
}
```

**Component File Structure** [Source: architecture/16-coding-standards.md#component-file-structure]:

```
/components/features/interpretation/
  ├── InterpretationForm.tsx         # Main form container
  ├── CultureSelector.tsx            # Reusable culture dropdown
  └── CharacterCounter.tsx           # Real-time character count display
```

### Data Models and Types

**Culture Type Definition** [Source: architecture/4-data-models.md#shared-typescript-types]:

```typescript
export type CultureCode =
  | 'american' | 'british' | 'german' | 'french' | 'japanese'
  | 'chinese' | 'indian' | 'spanish' | 'italian' | 'dutch'
  | 'korean' | 'brazilian' | 'mexican' | 'australian' | 'canadian';

export const CULTURE_NAMES: Record<CultureCode, string> = {
  american: 'American',
  british: 'British',
  german: 'German',
  french: 'French',
  japanese: 'Japanese',
  chinese: 'Chinese (Mandarin)',
  indian: 'Indian',
  spanish: 'Spanish',
  italian: 'Italian',
  dutch: 'Dutch',
  korean: 'Korean',
  brazilian: 'Brazilian Portuguese',
  mexican: 'Mexican',
  australian: 'Australian',
  canadian: 'Canadian',
};
```

**Interpretation Request Type** [Source: architecture/4-data-models.md#api-requestresponse-types]:

```typescript
export interface InterpretationRequest {
  message: string;                   // User's message text (max 2000 chars)
  sender_culture: CultureCode;       // Who sent the message
  receiver_culture: CultureCode;     // Who will receive the message
  mode: InterpretationType;          // 'inbound' or 'outbound'
}

export type InterpretationType = 'inbound' | 'outbound';
```

**Note:** Story 2.1 only implements 'inbound' mode. Outbound mode (message optimization) is deferred to future epic.

### UI Component Library (shadcn/ui)

**Why shadcn/ui** [Source: architecture/3-tech-stack.md]:

- Copy-paste components (not npm dependency, reduces bundle size)
- WCAG 2.1 AA compliant out-of-box (built on Radix UI)
- Customizable with Tailwind CSS
- Accessible keyboard navigation and ARIA attributes built-in

**Components to Install:**

```bash
# Button component (submit button)
npx shadcn-ui@latest add button

# Select component (culture dropdowns)
npx shadcn-ui@latest add select

# Textarea component (message input)
npx shadcn-ui@latest add textarea

# Tooltip component (disabled button hint)
npx shadcn-ui@latest add tooltip
```

**shadcn/ui Components Live In:** `/components/ui/` [Source: architecture/12-unified-project-structure.md]

### Form State Management (React Hook Form)

**Why React Hook Form** [Source: architecture/3-tech-stack.md, frontend best practices]:

- Lightweight (< 10KB gzipped)
- Built-in validation support
- Excellent TypeScript integration
- Optimized re-renders (only re-renders changed fields)
- Simple API: `register`, `handleSubmit`, `watch`, `formState`

**Installation:**

```bash
npm install react-hook-form
```

**Usage Pattern:**

```typescript
const { register, handleSubmit, watch, formState: { errors } } = useForm<InterpretationFormData>({
  defaultValues: {
    message: '',
    sender_culture: undefined,
    receiver_culture: undefined,
  },
});

// Watch message length in real-time for character counter
const message = watch('message');
const characterCount = message.length;

// Submit handler
const onSubmit = async (data: InterpretationFormData) => {
  setIsLoading(true);
  // TODO: Story 2.3 - Call /api/interpret endpoint
  console.log('Form data:', data);
  setIsLoading(false);
};
```

### Responsive Design (Tailwind CSS)

**Breakpoints** [Source: architecture/3-tech-stack.md, architecture/16-coding-standards.md]:

- **Mobile:** < 640px (default, no prefix needed)
- **Tablet:** 640px - 1024px (`sm:` and `md:` prefixes)
- **Desktop:** > 1024px (`lg:` and `xl:` prefixes)

**Responsive Form Layout:**

```typescript
<form className="w-full max-w-3xl mx-auto space-y-6 p-4 sm:p-6 lg:p-8">
  {/* Textarea: Full width on all devices */}
  <textarea className="w-full min-h-[150px] sm:min-h-[200px]" />

  {/* Culture selectors: Stack on mobile, side-by-side on desktop */}
  <div className="flex flex-col sm:flex-row gap-4">
    <CultureSelector label="Sender's Culture" />
    <CultureSelector label="Receiver's Culture" />
  </div>

  {/* Submit button: Full width on mobile, auto on desktop */}
  <button className="w-full sm:w-auto">Interpret</button>
</form>
```

**Touch Target Sizes (Mobile):**

Minimum 44x44px for touch targets per iOS Human Interface Guidelines and WCAG 2.1 success criterion 2.5.5.

```typescript
// ✅ GOOD - Large enough for touch
<button className="min-h-[44px] px-4">Interpret</button>

// ❌ BAD - Too small for touch
<button className="h-8 px-2">Interpret</button>
```

### Accessibility (WCAG 2.1 AA)

**Requirements** [Source: architecture/3-tech-stack.md, PRD accessibility requirements]:

1. **Keyboard Navigation:**
   - Tab through all form inputs in logical order
   - Enter submits form when button focused
   - Escape closes dropdowns

2. **Screen Reader Support:**
   - All inputs have clear labels (via `<label>` or `aria-label`)
   - Error messages associated with inputs (`aria-describedby`)
   - Dynamic updates announced (`aria-live` on character counter)

3. **Color Contrast:**
   - Text: 4.5:1 contrast ratio (WCAG AA)
   - Large text (≥24px): 3:1 contrast ratio
   - Warning state (red text): Still readable on background

4. **Visual Indicators (Not Color-Dependent):**
   - Character counter warning: Red text + bold weight + icon (not just color)
   - Disabled button: Opacity + cursor-not-allowed + tooltip (not just grayed out)

**shadcn/ui Accessibility Benefits:**

Built on Radix UI primitives, which provide:
- Correct ARIA roles and attributes
- Keyboard navigation out-of-box
- Focus management
- Screen reader announcements

### Character Counter Implementation

**Real-Time Update Pattern:**

```typescript
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';

export function InterpretationForm() {
  const { register, watch } = useForm<InterpretationFormData>();

  // Watch message field for real-time updates (React Hook Form optimization)
  const message = watch('message', '');
  const characterCount = message.length;
  const isOverLimit = characterCount > 2000;

  return (
    <div className="space-y-2">
      <textarea
        {...register('message', {
          required: 'Message is required',
          maxLength: { value: 2000, message: 'Message too long' }
        })}
        aria-describedby="character-counter"
      />

      <div
        id="character-counter"
        aria-live="polite"
        className={`text-sm ${isOverLimit ? 'text-red-600 font-semibold' : 'text-gray-600'}`}
      >
        {characterCount} / 2,000 characters
        {isOverLimit && ' - Message too long'}
      </div>
    </div>
  );
}
```

### Form Validation Rules

**Validation Requirements** (AC: 4, 8):

1. **Message:**
   - Required (cannot be empty)
   - Max length: 2000 characters
   - No minimum length (users can interpret short messages)

2. **Sender Culture:**
   - Required (must select from dropdown)
   - Must be valid CultureCode

3. **Receiver Culture:**
   - Required (must select from dropdown)
   - Must be valid CultureCode
   - CAN be same as sender culture (same-culture interpretation allowed)

**Submit Button Enable Logic:**

```typescript
const isFormValid =
  message.length > 0 &&
  message.length <= 2000 &&
  senderCulture !== undefined &&
  receiverCulture !== undefined;

<button disabled={!isFormValid || isLoading}>
  {isLoading ? 'Interpreting...' : 'Interpret'}
</button>
```

### Loading State Pattern

**Loading State Behavior** (AC: 9):

When form submitted:
1. Set `isLoading = true`
2. Disable all form inputs (textarea, selectors, button)
3. Change button text to "Interpreting..." with spinner icon
4. Disable form interactions (prevent double-submit)

After response received (success or error):
1. Set `isLoading = false`
2. Re-enable form inputs
3. Restore button to "Interpret" text
4. Display results or error message (Story 2.4)

**Implementation:**

```typescript
const [isLoading, setIsLoading] = useState(false);

const onSubmit = async (data: InterpretationFormData) => {
  setIsLoading(true);

  try {
    // TODO: Story 2.3 - Call /api/interpret endpoint
    console.log('Submitting:', data);

    // Simulate API call delay for testing
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Story 2.4 will handle result display
  } catch (error) {
    console.error('Interpretation failed:', error);
    // Story 2.4 will handle error display
  } finally {
    setIsLoading(false);
  }
};

// Spinner icon from Lucide React
import { Loader2 } from 'lucide-react';

<button disabled={isLoading}>
  {isLoading && <Loader2 className="animate-spin mr-2" />}
  {isLoading ? 'Interpreting...' : 'Interpret'}
</button>
```

### Integration with Story 2.3 (API Route)

**Story 2.1 Scope:** UI form only, NO API integration yet.

**Preparation for Story 2.3:**

1. **Form Data Structure:** Matches InterpretationRequest type exactly
2. **Placeholder Handler:** Logs form data to console for manual testing
3. **TODO Comment:** Marks where API call will be added in Story 2.3

```typescript
// TODO: Story 2.3 - Replace console.log with actual API call
const onSubmit = async (data: InterpretationFormData) => {
  setIsLoading(true);

  // Story 2.3 will replace this with:
  // const response = await fetch('/api/interpret', {
  //   method: 'POST',
  //   headers: { 'Content-Type': 'application/json' },
  //   body: JSON.stringify({ ...data, mode: 'inbound' }),
  // });

  console.log('Submitting interpretation request:', data);

  setIsLoading(false);
};
```

**Expected API Response Format** (for Story 2.3):

```typescript
interface InterpretationResponse {
  success: boolean;
  interpretation?: {
    bottomLine: string;
    culturalContext: string;
    emotions: Emotion[];
  };
  error?: {
    code: string;
    message: string;
  };
  messages_remaining?: number;
}
```

### Testing Strategy

**Unit Test Coverage** [Source: architecture/16-coding-standards.md#test-coverage-requirements]:

**Minimum Coverage for Components: 50%** (critical user interactions only)

**Test Cases to Implement:**

```typescript
// /tests/unit/components/features/interpretation/InterpretationForm.test.tsx

describe('InterpretationForm', () => {
  it('should render form with placeholder text', () => {
    render(<InterpretationForm />);
    expect(screen.getByPlaceholderText('Paste the message you want to interpret...')).toBeInTheDocument();
  });

  it('should update character counter in real-time', async () => {
    render(<InterpretationForm />);
    const textarea = screen.getByRole('textbox');
    await userEvent.type(textarea, 'Hello');
    expect(screen.getByText('5 / 2,000 characters')).toBeInTheDocument();
  });

  it('should turn character counter red when >2000 characters', async () => {
    render(<InterpretationForm />);
    const textarea = screen.getByRole('textbox');
    const longMessage = 'a'.repeat(2001);
    await userEvent.type(textarea, longMessage);
    const counter = screen.getByText(/2001 \/ 2,000 characters/);
    expect(counter).toHaveClass('text-red-600');
  });

  it('should disable submit button when message empty', () => {
    render(<InterpretationForm />);
    const button = screen.getByRole('button', { name: /interpret/i });
    expect(button).toBeDisabled();
  });

  it('should disable submit button when message >2000 characters', async () => {
    render(<InterpretationForm />);
    const textarea = screen.getByRole('textbox');
    const longMessage = 'a'.repeat(2001);
    await userEvent.type(textarea, longMessage);
    const button = screen.getByRole('button', { name: /interpret/i });
    expect(button).toBeDisabled();
  });

  it('should enable submit button when form valid', async () => {
    render(<InterpretationForm />);

    // Fill in message
    const textarea = screen.getByRole('textbox');
    await userEvent.type(textarea, 'Test message');

    // Select cultures
    await userEvent.selectOptions(screen.getByLabelText(/sender's culture/i), 'american');
    await userEvent.selectOptions(screen.getByLabelText(/receiver's culture/i), 'japanese');

    const button = screen.getByRole('button', { name: /interpret/i });
    expect(button).toBeEnabled();
  });

  it('should allow same-culture selection', async () => {
    render(<InterpretationForm />);

    // Select same culture for both
    await userEvent.selectOptions(screen.getByLabelText(/sender's culture/i), 'american');
    await userEvent.selectOptions(screen.getByLabelText(/receiver's culture/i), 'american');

    // Should not show validation error
    expect(screen.queryByText(/cultures must be different/i)).not.toBeInTheDocument();
  });

  it('should show loading state on form submission', async () => {
    render(<InterpretationForm />);

    // Fill form
    const textarea = screen.getByRole('textbox');
    await userEvent.type(textarea, 'Test message');
    await userEvent.selectOptions(screen.getByLabelText(/sender's culture/i), 'american');
    await userEvent.selectOptions(screen.getByLabelText(/receiver's culture/i), 'japanese');

    // Submit form
    const button = screen.getByRole('button', { name: /interpret/i });
    await userEvent.click(button);

    // Should show loading state
    expect(screen.getByText(/interpreting/i)).toBeInTheDocument();
    expect(button).toBeDisabled();
  });

  it('should populate culture selectors with all 15 cultures', () => {
    render(<InterpretationForm />);

    const senderSelect = screen.getByLabelText(/sender's culture/i);
    const options = within(senderSelect).getAllByRole('option');

    // Should have 16 options (15 cultures + placeholder "Select...")
    expect(options).toHaveLength(16);

    // Check a few specific cultures
    expect(screen.getByRole('option', { name: 'American' })).toBeInTheDocument();
    expect(screen.getByRole('option', { name: 'Japanese' })).toBeInTheDocument();
    expect(screen.getByRole('option', { name: 'Brazilian Portuguese' })).toBeInTheDocument();
  });
});
```

### Relevant Source Tree

```
towerofbabel/
├── app/
│   └── (dashboard)/
│       └── dashboard/
│           └── page.tsx                 # UPDATE: Replace form placeholder with InterpretationForm
├── components/
│   ├── features/
│   │   └── interpretation/
│   │       ├── InterpretationForm.tsx   # CREATE: Main form component
│   │       ├── CultureSelector.tsx      # CREATE: Reusable culture dropdown
│   │       └── CharacterCounter.tsx     # CREATE: Character count display
│   └── ui/                              # shadcn/ui components (auto-generated)
│       ├── button.tsx
│       ├── select.tsx
│       ├── textarea.tsx
│       └── tooltip.tsx
├── lib/
│   └── types/
│       └── models.ts                    # CREATE/UPDATE: CultureCode type, CULTURE_NAMES constant
├── tests/
│   └── unit/
│       └── components/
│           └── features/
│               └── interpretation/
│                   └── InterpretationForm.test.tsx  # CREATE: Unit tests
├── package.json                         # UPDATE: Add react-hook-form, lucide-react
└── README.md                            # UPDATE: Document new form feature (optional)
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Story created with comprehensive form UI implementation | Scrum Master (Bob) |

---

## Story Definition of Done (DoD) Checklist

### 1. Requirements Met:
- [ ] All functional requirements specified in the story are implemented.
- [ ] All acceptance criteria defined in the story are met (all 10 acceptance criteria verified).

### 2. Coding Standards & Project Structure:
- [ ] All new/modified code strictly adheres to coding standards (architecture/16-coding-standards.md).
- [ ] All new/modified code aligns with unified project structure (architecture/12-unified-project-structure.md).
- [ ] Adherence to tech stack for technologies/versions used (React, Tailwind CSS, shadcn/ui, React Hook Form).
- [ ] Basic security best practices applied (input validation, XSS prevention).
- [ ] No new linter errors introduced.
- [ ] Code is well-commented with JSDoc for all public functions and complex logic.

### 3. Testing:
- [ ] Unit tests written and passing (InterpretationForm component tests).
- [ ] Test coverage ≥ 50% for components (critical user interactions covered).
- [ ] Manual testing completed successfully (mobile, tablet, desktop).

### 4. Functionality & Verification:
- [ ] Functionality manually verified:
  - [ ] Form renders on dashboard
  - [ ] Character counter updates in real-time
  - [ ] Character counter turns red when >2000 characters
  - [ ] Submit button disabled when form invalid
  - [ ] Submit button enabled when form valid
  - [ ] Loading state displays on submit
  - [ ] Culture selectors populated with 15 cultures
  - [ ] Same-culture selection allowed
  - [ ] Form fully responsive on mobile, tablet, desktop
- [ ] Edge cases and error conditions handled:
  - [ ] Message with exactly 2000 characters
  - [ ] Message with 2001 characters
  - [ ] Same culture selected for sender and receiver
  - [ ] Form submission with valid inputs

### 5. Story Administration:
- [ ] All tasks within the story file are marked as complete.
- [ ] Clarifications and decisions documented in story file.
- [ ] Story wrap-up section completed (to be filled by dev agent).

### 6. Dependencies, Build & Configuration:
- [ ] Project builds successfully without errors (TypeScript compilation passed).
- [ ] Project linting passes (no errors, only acceptable warnings).
- [ ] Dependencies added to package.json:
  - [ ] react-hook-form
  - [ ] lucide-react
  - [ ] shadcn/ui components installed

### 7. Documentation (If Applicable):
- [ ] Inline code documentation complete (JSDoc for all components).
- [ ] README.md updated with form feature description (optional).
- [ ] Component usage examples documented in JSDoc comments.

---

## Final DoD Confirmation

**Summary of Deliverables:**
- ✅ Interpretation form UI with character counter
- ✅ Culture selector dropdowns with 15 cultures
- ✅ Real-time validation and visual feedback
- ✅ Loading state during form submission
- ✅ Fully responsive design (mobile, tablet, desktop)
- ✅ WCAG 2.1 AA accessibility compliance
- ✅ Unit tests for form behavior
- ✅ Integration preparation for Story 2.3 (API call placeholder)

**Manual Testing Required:**
- Form rendering on dashboard
- Character counter real-time updates
- Form validation behavior
- Loading state display
- Culture selector functionality
- Responsive design verification
- Accessibility testing (keyboard navigation, screen reader)

**Integration Points:**
- Story 1.5A: Form added to dashboard page (replaces placeholder)
- Story 2.3: Form submission will call /api/interpret endpoint (placeholder ready)
- Story 2.4: Results display will replace console.log (data structure ready)
