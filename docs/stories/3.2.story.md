# Story 3.2: Display Usage Indicator and Approaching-Limit Notifications

<!-- Powered by BMAD™ Core -->

## Status

**Draft**

---

## Story

**As a** user,
**I want** to see my current usage and be notified when approaching my limit,
**so that** I can decide whether to upgrade before being blocked.

---

## Acceptance Criteria

1. Usage indicator displayed in dashboard header/nav: "7/10 messages used" (for trial/Pro users)
2. Pay-as-you-go users see: "Pay-as-you-go: $0.50 per interpretation"
3. Usage indicator updates in real-time after each interpretation
4. Approaching-limit notification displayed when trial user reaches 8/10 messages:
   - In-app banner or toast: "You've used 8 of 10 trial messages. Upgrade to Pro or use Pay-As-You-Go after trial ends."
5. Approaching-limit notification displayed when Pro user reaches 80% of monthly limit
6. Notification includes link to upgrade modal or pricing page
7. Notification dismissible but reappears on next page load until limit issue resolved
8. Usage indicator color-coded: green (< 50% used), yellow (50-80% used), red (>80% used)
9. Usage indicator responsive (shows abbreviated version on mobile: "7/10")
10. Fetches latest usage count from database on page load

---

## Tasks / Subtasks

- [ ] **Task 1: Create Zustand Usage Store** (AC: 3)
  - [ ] Create `/lib/stores/usageStore.ts` with Zustand
  - [ ] Define `UsageState` interface:
    ```typescript
    interface UsageState {
      messagesUsed: number;
      messagesLimit: number | null;
      tier: 'trial' | 'payg' | 'pro';
      setUsage: (used: number, limit: number | null, tier: string) => void;
      incrementUsage: () => void;  // After successful interpretation
    }
    ```
  - [ ] Export `useUsageStore` hook
  - [ ] Add JSDoc documentation [Source: docs/architecture/16-coding-standards.md#jsdoc-for-public-apis]

- [ ] **Task 2: Create GET /api/user/usage Endpoint** (AC: 10)
  - [ ] Create `/app/api/user/usage/route.ts` API route
  - [ ] Implement GET handler with authentication (Supabase Auth)
  - [ ] Query database for user tier and usage (database-as-source-of-truth):
    ```typescript
    const userRecord = await prisma.user.findUnique({
      where: { id: user.id },
      select: {
        tier: true,
        messages_used_count: true,
        trial_start_date: true,
        messages_reset_date: true
      }
    });
    ```
  - [ ] Calculate messages_limit based on tier (trial: 10, pro: 100, payg: null)
  - [ ] Return standardized response:
    ```typescript
    {
      success: true,
      data: {
        tier: 'trial',
        messages_used: 7,
        messages_limit: 10,
        trial_end_date: '2025-11-05T00:00:00Z',  // If trial
        reset_date: '2025-12-01T00:00:00Z'       // If pro
      }
    }
    ```
  - [ ] Add rate limiting (IP-based, 100 req/min)
  - [ ] Wrap database query in connection circuit breaker
  - [ ] Add structured logging for debugging

- [ ] **Task 3: Create Compact UsageIndicator Component** (AC: 1, 2, 8, 9)
  - [ ] Create `/components/features/dashboard/UsageIndicator.tsx`
  - [ ] Make it a Client Component (`'use client'`)
  - [ ] Use `useUsageStore()` to access global state
  - [ ] Display tier-specific text:
    - Trial: "7/10 messages"
    - Pro: "45/100 messages"
    - PAYG: "$0.50 per interpretation"
  - [ ] Add color-coded badge/pill:
    ```typescript
    const getUsageColor = () => {
      if (!limit) return 'bg-blue-500';  // PAYG
      const percentage = (used / limit) * 100;
      if (percentage < 50) return 'bg-green-500';
      if (percentage < 80) return 'bg-yellow-500';
      return 'bg-red-500';
    };
    ```
  - [ ] Add responsive classes:
    ```tsx
    // Desktop: "7/10 messages used"
    <span className="hidden sm:inline">messages used</span>
    // Mobile: "7/10"
    <span className="sm:hidden" aria-label="messages used" />
    ```
  - [ ] Add Tooltip component (from shadcn/ui) for additional context on hover
  - [ ] Add WCAG 2.1 AA compliance: aria-labels, semantic HTML
  - [ ] Add JSDoc documentation

- [ ] **Task 4: Integrate UsageIndicator into DashboardNav** (AC: 1)
  - [ ] Modify `/components/layout/DashboardNav.tsx`
  - [ ] Add `<UsageIndicator />` to header/nav section
  - [ ] Position in top-right corner (desktop) or below user name (mobile)
  - [ ] Ensure nav remains accessible (keyboard navigation)
  - [ ] Test with different screen sizes (mobile/tablet/desktop)

- [ ] **Task 5: Create useUsageNotification Hook** (AC: 4, 5, 6, 7)
  - [ ] Create `/lib/hooks/useUsageNotification.ts` custom hook
  - [ ] Check if notification should be shown:
    ```typescript
    function shouldShowNotification(tier, used, limit): boolean {
      if (tier === 'trial' && used >= 8) return true;
      if (tier === 'pro' && limit && (used / limit) >= 0.8) return true;
      return false;
    }
    ```
  - [ ] Use localStorage to track dismissal:
    ```typescript
    const dismissedKey = `usage-notification-dismissed-${tier}-${used}`;
    const isDismissed = localStorage.getItem(dismissedKey);
    ```
  - [ ] Return notification data:
    ```typescript
    {
      show: boolean;
      message: string;
      onDismiss: () => void;
      upgradeUrl: '/pricing' // or modal trigger
    }
    ```
  - [ ] Add JSDoc documentation

- [ ] **Task 6: Install and Configure shadcn/ui Toast Component** (AC: 4, 5)
  - [ ] Run: `npx shadcn@latest add toast`
  - [ ] Verify toast component installed in `/components/ui/toast.tsx`
  - [ ] Add Toaster provider to root layout if not present
  - [ ] Test toast display with different variants (info, warning, error)

- [ ] **Task 7: Create UsageNotificationBanner Component** (AC: 4, 5, 6, 7)
  - [ ] Create `/components/features/dashboard/UsageNotificationBanner.tsx`
  - [ ] Make it a Client Component (`'use client'`)
  - [ ] Use `useUsageNotification()` hook
  - [ ] Display banner at top of dashboard when triggered:
    ```tsx
    <div className="bg-yellow-50 dark:bg-yellow-900/20 border-l-4 border-yellow-400 p-4">
      <p className="text-yellow-800 dark:text-yellow-200">
        {notificationMessage}
        <a href="/pricing" className="underline ml-2">Upgrade Now</a>
      </p>
      <button onClick={onDismiss} aria-label="Dismiss notification">×</button>
    </div>
    ```
  - [ ] Trial notification: "You've used 8 of 10 trial messages. Upgrade to Pro or use Pay-As-You-Go after trial ends."
  - [ ] Pro notification: "You've used 80 of 100 messages this month. Your usage resets on [reset_date]."
  - [ ] Add dismissible close button (X icon)
  - [ ] Implement onDismiss handler (saves to localStorage)
  - [ ] Style with Tailwind for responsive design
  - [ ] Add WCAG 2.1 AA compliance (keyboard navigation, ARIA labels)
  - [ ] Add JSDoc documentation

- [ ] **Task 8: Integrate Notification Banner into Dashboard Page** (AC: 4, 5)
  - [ ] Modify `/app/(dashboard)/page.tsx`
  - [ ] Add `<UsageNotificationBanner />` below header, above main content
  - [ ] Fetch initial usage data server-side (if possible) or client-side
  - [ ] Pass usage data to notification banner via Zustand store

- [ ] **Task 9: Add Usage Update Logic to InterpretationForm** (AC: 3)
  - [ ] Modify `/components/features/interpretation/InterpretationForm.tsx`
  - [ ] Import `useUsageStore` hook
  - [ ] On successful interpretation response:
    ```typescript
    const { incrementUsage } = useUsageStore();

    const handleSubmit = async (data) => {
      const response = await fetch('/api/interpret', { ... });
      if (response.ok) {
        const result = await response.json();
        incrementUsage();  // Update global state

        // Also update from server response if messages_remaining included
        if (result.metadata?.messages_remaining !== undefined) {
          setUsage(
            result.data.messages_used,
            result.data.messages_limit,
            result.data.tier
          );
        }
      }
    };
    ```
  - [ ] Handle optimistic updates (increment before response, rollback on error)
  - [ ] Test real-time update behavior

- [ ] **Task 10: Create useSyncUsageFromServer Hook** (AC: 10)
  - [ ] Create `/lib/hooks/useSyncUsageFromServer.ts` custom hook
  - [ ] Fetch usage from `/api/user/usage` on mount:
    ```typescript
    useEffect(() => {
      async function syncUsage() {
        const response = await fetch('/api/user/usage');
        if (response.ok) {
          const data = await response.json();
          setUsage(data.messages_used, data.messages_limit, data.tier);
        }
      }
      syncUsage();
    }, []);
    ```
  - [ ] Return loading state and error state
  - [ ] Add error handling (retry logic or fallback)
  - [ ] Add JSDoc documentation

- [ ] **Task 11: Integrate Usage Sync into Dashboard Page** (AC: 10)
  - [ ] Modify `/app/(dashboard)/page.tsx`
  - [ ] Call `useSyncUsageFromServer()` on page load
  - [ ] Show loading skeleton while fetching usage
  - [ ] Handle error state (display toast or banner)

- [ ] **Task 12: Write Unit Tests for usageStore**
  - [ ] Create `/tests/unit/lib/stores/usageStore.test.ts`
  - [ ] Test: Initial state is correct (messagesUsed: 0, tier: 'trial')
  - [ ] Test: setUsage updates state correctly
  - [ ] Test: incrementUsage increments messagesUsed
  - [ ] Test: State persists across multiple hook calls (Zustand behavior)
  - [ ] Use Vitest with @testing-library/react-hooks
  - [ ] Mock Zustand store for isolation

- [ ] **Task 13: Write Unit Tests for UsageIndicator Component**
  - [ ] Create `/tests/unit/components/features/dashboard/UsageIndicator.test.tsx`
  - [ ] Test: Renders "7/10 messages" for trial user
  - [ ] Test: Renders "$0.50 per interpretation" for PAYG user
  - [ ] Test: Shows green color when usage < 50%
  - [ ] Test: Shows yellow color when usage 50-80%
  - [ ] Test: Shows red color when usage > 80%
  - [ ] Test: Responsive text (full on desktop, abbreviated on mobile)
  - [ ] Test: Tooltip displays additional context
  - [ ] Mock useUsageStore with different states
  - [ ] Use Vitest + React Testing Library

- [ ] **Task 14: Write Unit Tests for useUsageNotification Hook**
  - [ ] Create `/tests/unit/lib/hooks/useUsageNotification.test.ts`
  - [ ] Test: Returns show: true when trial user at 8/10
  - [ ] Test: Returns show: true when Pro user at 80%
  - [ ] Test: Returns show: false when trial user at 7/10
  - [ ] Test: Returns show: false when notification dismissed (localStorage)
  - [ ] Test: Clears dismissal flag when usage threshold changes
  - [ ] Test: Trial notification message includes upgrade link
  - [ ] Test: Pro notification message includes reset date
  - [ ] Mock localStorage for testing

- [ ] **Task 15: Write Integration Tests for /api/user/usage Endpoint**
  - [ ] Create `/tests/integration/api/user/usage.test.ts`
  - [ ] Test: Returns 401 for unauthenticated requests
  - [ ] Test: Returns usage data for trial user (tier: 'trial', messages_used: 5)
  - [ ] Test: Returns usage data for Pro user with reset_date
  - [ ] Test: Returns usage data for PAYG user (messages_limit: null)
  - [ ] Test: Queries database (not JWT) for tier/usage
  - [ ] Test: Rate limiting (101st request returns 429)
  - [ ] Mock Supabase Auth and Prisma
  - [ ] Use Vitest + Supertest

- [ ] **Task 16: Write Integration Tests for Usage Update Flow**
  - [ ] Create `/tests/integration/usage-update-flow.test.tsx`
  - [ ] Test: Usage indicator updates after successful interpretation
  - [ ] Test: Notification banner appears when trial user reaches 8/10
  - [ ] Test: Notification banner dismisses and doesn't reappear (same session)
  - [ ] Test: Notification banner reappears on page reload (until limit resolved)
  - [ ] Test: Usage indicator reflects database state on page load
  - [ ] Mock API calls (/api/interpret, /api/user/usage)
  - [ ] Use Vitest + React Testing Library + MSW (Mock Service Worker)

- [ ] **Task 17: Manual Testing of Usage Indicator**
  - [ ] Create trial user with 3/10 messages
  - [ ] Load dashboard → verify "3/10 messages" displays in header
  - [ ] Verify green color indicator
  - [ ] Submit interpretation → verify indicator updates to "4/10" in real-time
  - [ ] Resize browser to mobile size → verify abbreviated "4/10" text
  - [ ] Test on actual mobile device (iOS/Android)
  - [ ] Verify tooltip shows additional context on hover

- [ ] **Task 18: Manual Testing of Notification Banner**
  - [ ] Create trial user with 7/10 messages
  - [ ] Submit interpretation → verify NO banner appears at 8/10
  - [ ] Wait for UI update → verify banner DOES appear at 8/10
  - [ ] Verify banner text: "You've used 8 of 10 trial messages..."
  - [ ] Click "Upgrade Now" link → verify redirects to /pricing (or opens modal)
  - [ ] Click dismiss button → verify banner disappears
  - [ ] Reload page → verify banner does NOT reappear (same session)
  - [ ] Increment to 9/10 → verify banner reappears (new threshold)
  - [ ] Test Pro user at 80% → verify Pro-specific notification

- [ ] **Task 19: Manual Testing of Usage Sync on Page Load**
  - [ ] Create trial user with 5/10 messages in database
  - [ ] Open dashboard in incognito mode (no localStorage)
  - [ ] Verify usage indicator shows "5/10" (fetched from database)
  - [ ] Open dashboard in second tab → verify both tabs show same usage
  - [ ] Submit interpretation in first tab → verify second tab updates (or doesn't, if no polling)
  - [ ] Verify loading skeleton displays during fetch

- [ ] **Task 20: Build and Lint Validation**
  - [ ] Run TypeScript compilation: `npx tsc --noEmit`
  - [ ] Verify no TypeScript errors
  - [ ] Run ESLint: `npm run lint`
  - [ ] Verify no ESLint errors (warnings acceptable)
  - [ ] Run unit tests: `npm test tests/unit`
  - [ ] Run integration tests: `npm test tests/integration`
  - [ ] Verify all tests pass
  - [ ] Check bundle size impact (< 300KB total goal)

- [ ] **Task 21: Commit Changes**
  - [ ] Stage all changes: `git add .`
  - [ ] Commit with conventional commit message: `feat(usage): add usage indicator and approaching-limit notifications (Story 3.2)` [Source: docs/architecture/16-coding-standards.md#conventional-commits]
  - [ ] Push to GitHub: `git push origin main`
  - [ ] Verify CI pipeline passes

---

## Dev Notes

### Story Context and Integration

**This story adds real-time usage tracking UI components to complement the backend enforcement logic from Story 3.1.**

**Integration Flow:**
- Story 3.1: Backend usage limit enforcement with trial expiration and Pro resets (DONE)
- **Story 3.2 (THIS STORY):** Frontend usage indicator + approaching-limit notifications
- Story 3.3: Upgrade modal with pricing tiers
- Story 3.4: Lemon Squeezy payment integration
- Story 3.5: Billing portal and subscription management

**Key Insights from Story 3.1:**
- `/api/interpret` now returns enhanced error responses with usage details
- Database has `trial_start_date` and `messages_reset_date` fields
- `usageService.ts` enforces limits with dual conditions (message count + time expiration)
- Error responses include `messages_used`, `messages_limit`, `reset_date` for frontend display

**What Story 3.2 Adds:**
- ✨ **NEW:** Compact usage indicator in dashboard header/nav
- ✨ **NEW:** Zustand store for global usage state
- ✨ **NEW:** `/api/user/usage` endpoint for fetching latest usage
- ✨ **NEW:** Approaching-limit notification banner (trial: 8/10, pro: 80%)
- ✨ **NEW:** Real-time usage updates after interpretations
- ✨ **NEW:** Responsive design (abbreviated mobile view)

---

### CRITICAL Architectural Patterns (Continued from Story 3.1)

#### Client-Side State Management with Zustand

**Pattern:** Use Zustand for global UI state that needs to be shared across multiple components.

```typescript
// /lib/stores/usageStore.ts
import { create } from 'zustand';

interface UsageState {
  messagesUsed: number;
  messagesLimit: number | null;
  tier: 'trial' | 'payg' | 'pro';
  setUsage: (used: number, limit: number | null, tier: string) => void;
  incrementUsage: () => void;
}

export const useUsageStore = create<UsageState>((set) => ({
  messagesUsed: 0,
  messagesLimit: null,
  tier: 'trial',
  setUsage: (used, limit, tier) => set({ messagesUsed: used, messagesLimit: limit, tier }),
  incrementUsage: () => set((state) => ({ messagesUsed: state.messagesUsed + 1 })),
}));
```

**Why Zustand:**
- Lightweight (< 5KB) vs Redux (45KB)
- No provider boilerplate (works across component tree automatically)
- Simple API (create + hooks)
- Perfect for usage counter that updates in multiple places

**Usage Example:**
```typescript
// In UsageIndicator component
import { useUsageStore } from '@/lib/stores/usageStore';

export function UsageIndicator() {
  const { messagesUsed, messagesLimit, tier } = useUsageStore();
  return <span>{messagesUsed}/{messagesLimit} messages</span>;
}

// In InterpretationForm component
import { useUsageStore } from '@/lib/stores/usageStore';

export function InterpretationForm() {
  const { incrementUsage } = useUsageStore();

  const handleSubmit = async () => {
    const result = await interpretMessage(...);
    incrementUsage();  // Updates UsageIndicator automatically
  };
}
```

[Source: docs/architecture/10-frontend-architecture.md, docs/architecture/3-tech-stack.md]

---

#### Server-Side Data Fetching on Page Load

**Pattern:** Fetch initial usage data from database on page load to ensure accuracy.

```typescript
// /app/(dashboard)/page.tsx (Server Component)
import { createClient } from '@/lib/auth/supabaseServer';
import { UsageSyncProvider } from '@/components/features/dashboard/UsageSyncProvider';

export default async function DashboardPage() {
  const supabase = createClient();
  const { data: { user } } = await supabase.auth.getUser();

  // Fetch usage from database (server-side)
  const userRecord = await prisma.user.findUnique({
    where: { id: user.id },
    select: { tier: true, messages_used_count: true }
  });

  return (
    <>
      <UsageSyncProvider initialData={userRecord} />
      <UsageIndicator />
      <InterpretationForm />
    </>
  );
}
```

**Alternative (Client-Side Fetch):**
```typescript
// /components/features/dashboard/UsageSyncProvider.tsx (Client Component)
'use client';

export function UsageSyncProvider({ children }) {
  const { setUsage } = useUsageStore();

  useEffect(() => {
    async function fetchUsage() {
      const response = await fetch('/api/user/usage');
      const data = await response.json();
      setUsage(data.messages_used, data.messages_limit, data.tier);
    }
    fetchUsage();
  }, []);

  return <>{children}</>;
}
```

**Why This Pattern:**
- Ensures usage indicator reflects actual database state (not stale client-side cache)
- Prevents race conditions between multiple tabs/devices
- Complements database-as-source-of-truth pattern from Story 3.1

[Source: docs/architecture/14-critical-risk-mitigation.md#risk-1]

---

### Usage Notification Logic

**When to Show Notification:**

**Trial Users (AC: 4):**
```typescript
// Show notification when user reaches 8/10 messages
if (tier === 'trial' && messagesUsed >= 8 && messagesUsed < 10) {
  return {
    show: true,
    message: "You've used 8 of 10 trial messages. Upgrade to Pro or use Pay-As-You-Go after trial ends.",
    variant: 'warning',
    upgradeUrl: '/pricing'  // Story 3.3 will create upgrade modal
  };
}

// Don't show if already at limit (Story 3.3 upgrade modal handles this)
if (tier === 'trial' && messagesUsed >= 10) {
  return { show: false };  // Upgrade modal takes over
}
```

**Pro Users (AC: 5):**
```typescript
// Show notification when user reaches 80% of monthly limit
if (tier === 'pro' && messagesLimit && (messagesUsed / messagesLimit) >= 0.8) {
  const resetDate = new Date(messagesResetDate).toLocaleDateString();
  return {
    show: true,
    message: `You've used ${messagesUsed} of ${messagesLimit} messages this month. Your usage resets on ${resetDate}.`,
    variant: 'info',
    upgradeUrl: null  // No upgrade needed, just informational
  };
}
```

**PAYG Users:**
```typescript
// No notification for PAYG (they pay per use, no limit)
if (tier === 'payg') {
  return { show: false };
}
```

**Dismissal Logic (AC: 7):**
```typescript
// Store dismissal in localStorage with usage-specific key
const dismissalKey = `usage-notification-dismissed-${tier}-${messagesUsed}`;

function onDismiss() {
  localStorage.setItem(dismissalKey, 'true');
  setShowNotification(false);
}

// Check if user dismissed notification at this usage level
const isDismissed = localStorage.getItem(dismissalKey) === 'true';
if (isDismissed) {
  return { show: false };
}

// Notification reappears if usage increases (new threshold)
// e.g., dismissed at 8/10, but now at 9/10 → show again
```

**Why This Approach:**
- Prevents notification spam (user can dismiss)
- Reappears if usage increases (user needs to be reminded)
- Reappears on page reload (until limit issue resolved)
- Different keys for different usage levels (8/10 vs 9/10)

[Source: Epic 3 AC 4, 5, 7]

---

### Color-Coding System (AC: 8)

**Usage Percentage to Color Mapping:**

```typescript
function getUsageColor(used: number, limit: number | null): string {
  if (!limit) {
    // PAYG users: neutral blue
    return 'bg-blue-500 text-blue-900 dark:text-blue-100';
  }

  const percentage = (used / limit) * 100;

  if (percentage < 50) {
    // Green: Healthy usage (< 50%)
    return 'bg-green-500 text-green-900 dark:text-green-100';
  }

  if (percentage < 80) {
    // Yellow: Moderate usage (50-80%)
    return 'bg-yellow-500 text-yellow-900 dark:text-yellow-100';
  }

  // Red: High usage (> 80%)
  return 'bg-red-500 text-red-900 dark:text-red-100';
}
```

**WCAG 2.1 AA Compliance:**
- Green: 4.5:1 contrast ratio (text on green-500 background)
- Yellow: 4.5:1 contrast ratio (text on yellow-500 background)
- Red: 4.5:1 contrast ratio (text on red-500 background)
- Dark mode: Inverse colors with same contrast ratio

**Visual Examples:**
```
Trial User Examples:
- 3/10 messages: [●●●-------] GREEN   (30%)
- 7/10 messages: [●●●●●●●---] YELLOW  (70%)
- 9/10 messages: [●●●●●●●●●-] RED     (90%)

Pro User Examples:
- 30/100 messages: [●●●-------] GREEN   (30%)
- 65/100 messages: [●●●●●●----] YELLOW  (65%)
- 95/100 messages: [●●●●●●●●●-] RED     (95%)
```

[Source: Epic 3 AC 8, docs/architecture/front-end-spec.md]

---

### Responsive Design Pattern (AC: 9)

**Mobile-First Approach:**

```tsx
// Full text on desktop (sm: 640px+)
<div className="flex items-center gap-2">
  <span className={`px-3 py-1 rounded-full ${getUsageColor()}`}>
    {messagesUsed}/{messagesLimit}
    <span className="hidden sm:inline"> messages used</span>
  </span>
</div>

// Abbreviated text on mobile (< 640px)
// Screen reader still gets full context via aria-label
<span className="sr-only">messages used</span>
```

**Tailwind Breakpoints:**
- Mobile: < 640px → "7/10"
- Tablet: 640px - 1024px → "7/10 messages"
- Desktop: 1024px+ → "7/10 messages used"

**Tooltip for Additional Context:**
```tsx
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';

<TooltipProvider>
  <Tooltip>
    <TooltipTrigger asChild>
      <span className={`px-3 py-1 rounded-full ${getUsageColor()}`}>
        {messagesUsed}/{messagesLimit}
        <span className="hidden sm:inline"> messages used</span>
      </span>
    </TooltipTrigger>
    <TooltipContent>
      <p>
        {tier === 'trial'
          ? 'Trial: 10 messages, expires after 14 days'
          : `Pro: ${messagesLimit} messages/month, resets ${resetDate}`}
      </p>
    </TooltipContent>
  </Tooltip>
</TooltipProvider>
```

[Source: docs/architecture/10-frontend-architecture.md, Epic 3 AC 9]

---

### API Endpoint Design: GET /api/user/usage

**Endpoint Specification:**

```typescript
// /app/api/user/usage/route.ts
export async function GET(req: NextRequest) {
  // 1. AUTHENTICATION
  const supabase = createClient();
  const { data: { user }, error } = await supabase.auth.getUser();

  if (error || !user) {
    return NextResponse.json(
      { success: false, error: { code: 'UNAUTHORIZED', message: 'Authentication required' }},
      { status: 401 }
    );
  }

  // 2. RATE LIMITING (100 req/min per IP)
  const ip = req.headers.get('x-forwarded-for') || 'unknown';
  if (!checkRateLimit(ip, 100)) {
    return NextResponse.json(
      { success: false, error: { code: 'RATE_LIMITED', message: 'Too many requests' }},
      { status: 429 }
    );
  }

  // 3. DATABASE QUERY (database-as-source-of-truth)
  const userRecord = await executeWithCircuitBreaker(() =>
    prisma.user.findUnique({
      where: { id: user.id },
      select: {
        tier: true,
        messages_used_count: true,
        trial_start_date: true,
        messages_reset_date: true
      }
    })
  );

  if (!userRecord) {
    return NextResponse.json(
      { success: false, error: { code: 'USER_NOT_FOUND', message: 'User not found' }},
      { status: 404 }
    );
  }

  // 4. CALCULATE MESSAGES LIMIT
  let messagesLimit: number | null = null;
  if (userRecord.tier === 'trial') {
    messagesLimit = parseInt(process.env.TRIAL_MESSAGE_LIMIT || '10');
  } else if (userRecord.tier === 'pro') {
    messagesLimit = parseInt(process.env.PRO_MESSAGE_LIMIT || '100');
  }
  // PAYG: messagesLimit = null (unlimited)

  // 5. CALCULATE TRIAL END DATE (if applicable)
  let trialEndDate: string | null = null;
  if (userRecord.tier === 'trial' && userRecord.trial_start_date) {
    const trialDaysLimit = parseInt(process.env.TRIAL_DAYS_LIMIT || '14');
    trialEndDate = new Date(
      userRecord.trial_start_date.getTime() + trialDaysLimit * 24 * 60 * 60 * 1000
    ).toISOString();
  }

  // 6. RESPONSE
  return NextResponse.json({
    success: true,
    data: {
      tier: userRecord.tier,
      messages_used: userRecord.messages_used_count,
      messages_limit: messagesLimit,
      trial_end_date: trialEndDate,
      reset_date: userRecord.messages_reset_date?.toISOString() || null
    }
  });
}
```

**Response Format:**

```typescript
// Trial User Response
{
  success: true,
  data: {
    tier: 'trial',
    messages_used: 7,
    messages_limit: 10,
    trial_end_date: '2025-11-05T00:00:00Z',
    reset_date: null
  }
}

// Pro User Response
{
  success: true,
  data: {
    tier: 'pro',
    messages_used: 65,
    messages_limit: 100,
    trial_end_date: null,
    reset_date: '2025-12-01T00:00:00Z'
  }
}

// PAYG User Response
{
  success: true,
  data: {
    tier: 'payg',
    messages_used: 45,
    messages_limit: null,
    trial_end_date: null,
    reset_date: null
  }
}
```

**Rate Limiting:**
- 100 requests per minute per IP (more lenient than /api/interpret)
- Why: Dashboard may poll this endpoint periodically for usage updates
- Implementation: Vercel KV (Redis) with sliding window

[Source: docs/architecture/5-api-specification.md, docs/architecture/16-coding-standards.md#api-response-format]

---

### Existing Components to Leverage

**From Story 2.4:**
- `/components/ui/progress.tsx` (shadcn/ui Progress component)
- `/components/ui/tooltip.tsx` (shadcn/ui Tooltip component)
- Progress bar implementation pattern with WCAG 2.1 AA compliance

**From Existing Dashboard:**
- `/components/features/dashboard/UsageDisplay.tsx` (full-page usage display)
  - **Note:** This is a full-page component, Story 3.2 creates a *compact header version*
  - Reuse color-coding logic: `getProgressBarColor()` function
  - Reuse upgrade CTA trigger logic: `showUpgradeCTA` calculation
- `/components/features/dashboard/DashboardHeader.tsx` (welcome header)
  - **Modify:** Add UsageIndicator to header section

**What's Reusable:**
```typescript
// Color-coding logic (from UsageDisplay.tsx)
const getProgressBarColor = (percentage: number): string => {
  if (percentage < 50) return 'bg-green-500';
  if (percentage < 80) return 'bg-yellow-500';
  return 'bg-red-500';
};

// Upgrade CTA trigger logic
const showUpgradeCTA = tier === 'trial' && messagesUsed >= 8;
```

**What's New:**
- Compact UsageIndicator (badge/pill format, not full progress bar)
- Zustand store for global state
- `/api/user/usage` endpoint
- Notification banner system with dismissal

[Source: File inspection of components/features/dashboard/UsageDisplay.tsx]

---

### File Locations and Project Structure

**Files to Create:**
```
/lib/stores/
  └── usageStore.ts                         # CREATE: Zustand store for usage state

/lib/hooks/
  ├── useUsageNotification.ts               # CREATE: Custom hook for notification logic
  └── useSyncUsageFromServer.ts             # CREATE: Custom hook for initial data fetch

/app/api/user/usage/
  └── route.ts                              # CREATE: GET endpoint for usage data

/components/features/dashboard/
  ├── UsageIndicator.tsx                    # CREATE: Compact header usage indicator
  └── UsageNotificationBanner.tsx           # CREATE: Approaching-limit notification banner

/tests/unit/lib/stores/
  └── usageStore.test.ts                    # CREATE: Zustand store tests

/tests/unit/lib/hooks/
  ├── useUsageNotification.test.ts          # CREATE: Notification hook tests
  └── useSyncUsageFromServer.test.ts        # CREATE: Data sync hook tests

/tests/unit/components/features/dashboard/
  ├── UsageIndicator.test.tsx               # CREATE: Usage indicator component tests
  └── UsageNotificationBanner.test.tsx      # CREATE: Notification banner component tests

/tests/integration/api/user/
  └── usage.test.ts                         # CREATE: Usage endpoint integration tests

/tests/integration/
  └── usage-update-flow.test.tsx            # CREATE: End-to-end usage update flow tests
```

**Files to Modify:**
```
/components/layout/
  └── DashboardNav.tsx                      # MODIFY: Add UsageIndicator component

/app/(dashboard)/
  └── page.tsx                              # MODIFY: Add UsageNotificationBanner, usage sync

/components/features/interpretation/
  └── InterpretationForm.tsx                # MODIFY: Add usage update logic after interpretation
```

[Source: docs/architecture/12-unified-project-structure.md]

---

### Relevant Source Tree

```
towerofbabel/
├── app/
│   ├── (dashboard)/
│   │   └── page.tsx                        # MODIFY: Add usage sync + notification banner
│   └── api/
│       └── user/
│           └── usage/
│               └── route.ts                # CREATE: GET /api/user/usage endpoint
├── components/
│   ├── ui/                                 # EXISTING: shadcn/ui primitives
│   │   ├── progress.tsx                    # Use for progress bar (if needed)
│   │   ├── tooltip.tsx                     # Use for usage indicator tooltip
│   │   └── toast.tsx                       # Install via shadcn CLI
│   ├── features/
│   │   ├── dashboard/
│   │   │   ├── UsageDisplay.tsx            # EXISTING: Full-page usage display (reuse logic)
│   │   │   ├── DashboardHeader.tsx         # EXISTING: Welcome header
│   │   │   ├── UsageIndicator.tsx          # CREATE: Compact header usage indicator
│   │   │   └── UsageNotificationBanner.tsx # CREATE: Approaching-limit notification
│   │   └── interpretation/
│   │       └── InterpretationForm.tsx      # MODIFY: Add usage update logic
│   └── layout/
│       └── DashboardNav.tsx                # MODIFY: Add UsageIndicator to header
├── lib/
│   ├── stores/
│   │   └── usageStore.ts                   # CREATE: Zustand global usage state
│   ├── hooks/
│   │   ├── useUsageNotification.ts         # CREATE: Notification logic hook
│   │   └── useSyncUsageFromServer.ts       # CREATE: Server data sync hook
│   └── services/
│       └── usageService.ts                 # EXISTING (Story 3.1): Backend usage logic
├── tests/
│   ├── unit/
│   │   ├── lib/
│   │   │   ├── stores/
│   │   │   │   └── usageStore.test.ts      # CREATE: Store tests
│   │   │   └── hooks/
│   │   │       ├── useUsageNotification.test.ts  # CREATE: Hook tests
│   │   │       └── useSyncUsageFromServer.test.ts
│   │   └── components/
│   │       └── features/
│   │           └── dashboard/
│   │               ├── UsageIndicator.test.tsx         # CREATE
│   │               └── UsageNotificationBanner.test.tsx # CREATE
│   └── integration/
│       ├── api/
│       │   └── user/
│       │       └── usage.test.ts            # CREATE: Endpoint tests
│       └── usage-update-flow.test.tsx       # CREATE: E2E flow tests
└── package.json                             # MODIFY: Add zustand dependency
```

---

### Testing Strategy

**Unit Tests (Target: 80% Coverage):**

1. **Zustand Store Tests** (`usageStore.test.ts`):
   - Initial state is correct (messagesUsed: 0, tier: 'trial')
   - setUsage updates state correctly
   - incrementUsage increments messagesUsed
   - State persists across multiple hook calls

2. **UsageIndicator Component Tests** (`UsageIndicator.test.tsx`):
   - Renders "7/10 messages" for trial user
   - Renders "$0.50 per interpretation" for PAYG user
   - Shows correct color (green/yellow/red) based on usage percentage
   - Responsive text (full on desktop, abbreviated on mobile)
   - Tooltip displays additional context

3. **useUsageNotification Hook Tests** (`useUsageNotification.test.ts`):
   - Returns show: true when trial user at 8/10
   - Returns show: true when Pro user at 80%
   - Returns show: false when dismissed (localStorage)
   - Clears dismissal flag when usage threshold changes

**Integration Tests (Target: 60% Coverage):**

4. **GET /api/user/usage Endpoint Tests** (`usage.test.ts`):
   - Returns 401 for unauthenticated requests
   - Returns usage data for trial user (tier, messages_used, trial_end_date)
   - Returns usage data for Pro user (with reset_date)
   - Returns usage data for PAYG user (messages_limit: null)
   - Queries database (not JWT) for tier/usage
   - Rate limiting (101st request returns 429)

5. **Usage Update Flow Tests** (`usage-update-flow.test.tsx`):
   - Usage indicator updates after successful interpretation
   - Notification banner appears when trial user reaches 8/10
   - Notification banner dismisses and doesn't reappear (same session)
   - Notification banner reappears on page reload (until limit resolved)
   - Usage indicator reflects database state on page load

**Testing Framework:**
- **Unit Tests:** Vitest + React Testing Library + @testing-library/react-hooks
- **Integration Tests:** Vitest + Supertest + MSW (Mock Service Worker)
- **Mocking Strategy:**
  - Mock Supabase Auth: `vi.mock('@/lib/auth/supabaseServer')`
  - Mock Prisma: `vi.mock('@prisma/client')`
  - Mock localStorage: `vi.stubGlobal('localStorage', mockLocalStorage)`
  - Mock Zustand store: Use `create` with initial state for testing

[Source: docs/architecture/16-coding-standards.md#testing-standards, docs/architecture/3-tech-stack.md]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Story created with usage indicator and notification system implementation | Scrum Master (Bob) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_

---
